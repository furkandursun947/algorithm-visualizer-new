{
  "categories": [
    {
      "id": "sorting",
      "name": "Sorting Algorithms",
      "description": "Algorithms that arrange elements in a specific order (ascending or descending).",
      "algorithms": [
        {
          "id": "bubble-sort",
          "name": "Bubble Sort",
          "description": "Repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n²)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<p>Bubble Sort is one of the simplest sorting algorithms that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Simplicity:</span> Very straightforward to understand and implement.</li>",
            "  <li><span class=\"font-medium\">In-place Sorting:</span> Requires minimal extra space.</li>",
            "  <li><span class=\"font-medium\">Stable:</span> Maintains the relative order of equal elements.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Start from the first element of the array</li>",
            "    <li>Compare the current element with the next element</li>",
            "    <li>If the current element is greater than the next element, swap them</li>",
            "    <li>Move to the next element and repeat steps 2-3 until the end of array</li>",
            "    <li>After one complete pass, the largest element will be at the end</li>",
            "    <li>Repeat steps 1-5 for remaining elements (excluding the sorted part)</li>",
            "    <li>Continue until no more swaps are needed in a pass</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>In each pass, the algorithm \"bubbles up\" the largest unsorted element to its correct position at the end of the unsorted section, similar to how air bubbles rise to the surface in water.</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    [5, 3, 8, 4, 2] → Compare 5 & 3 → Swap → [3, 5, 8, 4, 2]<br/>",
            "    [3, 5, 8, 4, 2] → Compare 5 & 8 → No swap<br/>",
            "    [3, 5, 8, 4, 2] → Compare 8 & 4 → Swap → [3, 5, 4, 8, 2]<br/>",
            "    [3, 5, 4, 8, 2] → Compare 8 & 2 → Swap → [3, 5, 4, 2, 8]<br/>",
            "    After first pass: [3, 5, 4, 2, 8] (8 is in correct position)",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n) - when the array is already sorted (with optimization)</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O(n²) - requires approximately n²/2 comparisons and n²/2 swaps</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n²) - when the array is sorted in reverse order</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(1) - in-place sorting with constant extra space</li>",
            "</ul>",
            "<p>Despite its inefficiency for large datasets, Bubble Sort is useful for:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Educational purposes to introduce sorting concepts</li>",
            "  <li>Small datasets where implementation simplicity is valued</li>",
            "  <li>Datasets that are already nearly sorted</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure bubbleSort(A: list of sortable items)",
            "    n := length(A)",
            "    repeat",
            "        swapped := false",
            "        for i := 1 to n-1 inclusive do",
            "            if A[i-1] > A[i] then",
            "                swap(A[i-1], A[i])",
            "                swapped := true",
            "            end if",
            "        end for",
            "        n := n - 1",
            "    until not swapped",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start with an unsorted array",
            "Compare adjacent elements",
            "Swap if they are in the wrong order",
            "Continue to the end of the array",
            "Repeat until no swaps are needed"
          ]
        },
        {
          "id": "selection-sort",
          "name": "Selection Sort",
          "description": "Divides the input list into sorted and unsorted regions, repeatedly selecting the smallest element from the unsorted region.",
          "timeComplexity": {
            "best": "O(n²)",
            "average": "O(n²)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<p>Selection Sort is an in-place comparison sorting algorithm that divides the input list into two parts: a sorted sublist and an unsorted sublist, repeatedly selecting the smallest element from the unsorted sublist and moving it to the end of the sorted sublist:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Simplicity:</span> Easy to understand and implement.</li>",
            "  <li><span class=\"font-medium\">In-place Sorting:</span> Only requires a single additional memory space for temporary storage.</li>",
            "  <li><span class=\"font-medium\">Minimal Swaps:</span> Makes only O(n) swaps, which can be advantageous when memory write is costly.</li>",
            "  <li><span class=\"font-medium\">Not Stable:</span> May change the relative order of equal elements.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Set the first element as the minimum</li>",
            "    <li>Compare this with all elements in the unsorted sublist</li>",
            "    <li>If a smaller element is found, set that as the new minimum</li>",
            "    <li>After going through all elements, swap the minimum with the first element of the unsorted sublist</li>",
            "    <li>Move the boundary between sorted and unsorted sublists one element to the right</li>",
            "    <li>Repeat until the entire list is sorted</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>The algorithm divides the array into a sorted region (left) and an unsorted region (right), repeatedly finding the minimum element in the unsorted region and moving it to the end of the sorted region.</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    [64, 25, 12, 22, 11] → Find minimum (11) → Swap with first element → [11, 25, 12, 22, 64]<br/>",
            "    [11, 25, 12, 22, 64] → Find minimum in remaining (12) → Swap with second element → [11, 12, 25, 22, 64]<br/>",
            "    [11, 12, 25, 22, 64] → Find minimum in remaining (22) → Swap with third element → [11, 12, 22, 25, 64]<br/>",
            "    [11, 12, 22, 25, 64] → Find minimum in remaining (25) → Already in position, no swap<br/>",
            "    Final result: [11, 12, 22, 25, 64]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n²) - always requires scanning entire unsorted portion</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O(n²) - as it makes ~n²/2 comparisons</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n²) - same as average case</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(1) - in-place sorting algorithm</li>",
            "</ul>",
            "<p>Selection Sort performs better than Bubble Sort in certain scenarios because:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It performs a maximum of n swaps (compared to O(n²) for Bubble Sort)</li>",
            "  <li>It's useful when memory writes are expensive but comparisons are not</li>",
            "  <li>It's simple to implement and understand for educational purposes</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure selectionSort(A: list of sortable items)",
            "    n := length(A)",
            "    for i := 0 to n-1 inclusive do",
            "        min_idx := i",
            "        for j := i+1 to n inclusive do",
            "            if A[j] < A[min_idx] then",
            "                min_idx := j",
            "            end if",
            "        end for",
            "        if min_idx ≠ i then",
            "            swap(A[i], A[min_idx])",
            "        end if",
            "    end for",
            "end procedure"
          ],
          "visualizationSteps": [
            "Divide array into sorted and unsorted parts",
            "Find minimum element in unsorted array",
            "Swap with first element of unsorted part",
            "Move boundary between sorted and unsorted",
            "Repeat until array is sorted"
          ]
        },
        {
          "id": "insertion-sort",
          "name": "Insertion Sort",
          "description": "Builds the final sorted array one item at a time, similar to sorting playing cards in your hand.",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n²)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<p>Insertion Sort is a simple sorting algorithm that builds the final sorted array one item at a time, similar to how people sort playing cards in their hands:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Simplicity:</span> Intuitive and easy to implement.</li>",
            "  <li><span class=\"font-medium\">Adaptive:</span> Efficient for small data sets and nearly sorted data.</li>",
            "  <li><span class=\"font-medium\">Incremental:</span> Sorts the data one element at a time.</li>",
            "  <li><span class=\"font-medium\">In-place:</span> Only requires a constant amount of extra memory space.</li>",
            "  <li><span class=\"font-medium\">Stable:</span> Preserves the relative order of equal elements.</li>",
            "  <li><span class=\"font-medium\">Online:</span> Can sort a list as it receives it.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Start with the second element (consider the first element as already sorted)</li>",
            "    <li>Compare the current element with the previous elements</li>",
            "    <li>If the previous element is greater, move it one position ahead</li>",
            "    <li>Continue comparing and moving elements until the correct position for the current element is found</li>",
            "    <li>Insert the current element at its correct position</li>",
            "    <li>Repeat steps 2-5 for all elements in the array</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>The array is divided into a sorted region and an unsorted region. We take elements one by one from the unsorted region and insert them at their correct positions in the sorted region, similar to sorting playing cards.</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    [5, 2, 4, 6, 1, 3]<br/>",
            "    Start with [5] as sorted portion<br/>",
            "    Take 2: [5, 2] → 2&lt;5, shift 5 → [2, 5]<br/>",
            "    Take 4: [2, 5, 4] → 4&lt;5, shift 5 → [2, 4, 5]<br/>",
            "    Take 6: [2, 4, 5, 6] → 6>5, no shifts needed<br/>",
            "    Take 1: [2, 4, 5, 6, 1] → 1&lt;all, shift all → [1, 2, 4, 5, 6]<br/>",
            "    Take 3: [1, 2, 4, 5, 6, 3] → 3&lt;4,5,6, shift them → [1, 2, 3, 4, 5, 6]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n) - when the array is already sorted</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O(n²) - requires comparing and shifting elements</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n²) - when the array is sorted in reverse order</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(1) - in-place algorithm with constant extra space</li>",
            "</ul>",
            "<p>Insertion Sort is particularly efficient:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>For small datasets (outperforms advanced algorithms like Quick Sort)</li>",
            "  <li>When the array is already partially sorted</li>",
            "  <li>When used as part of more complex algorithms (like introsort)</li>",
            "  <li>In online scenarios where you sort elements as they arrive</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure insertionSort(A: list of sortable items)",
            "    for i := 1 to length(A) - 1 inclusive do",
            "        j := i",
            "        while j > 0 and A[j-1] > A[j] do",
            "            swap(A[j], A[j-1])",
            "            j := j - 1",
            "        end while",
            "    end for",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start with first element considered sorted",
            "Take next element and insert into sorted section",
            "Compare with previous elements",
            "Shift elements to make space",
            "Repeat until all elements are sorted"
          ]
        },
        {
          "id": "merge-sort",
          "name": "Merge Sort",
          "description": "Divides the array into halves, sorts them recursively, and then merges the sorted halves.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n log n)",
            "worst": "O(n log n)"
          },
          "spaceComplexity": "O(n)",
          "howItWorks": [
            "<p>Merge Sort is an efficient, stable, comparison-based, divide and conquer sorting algorithm that divides the unsorted list into n sublists, each containing one element, then repeatedly merges sublists to produce new sorted sublists until only one sublist remains:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Divide and Conquer:</span> Breaks the problem into smaller, manageable subproblems.</li>",
            "  <li><span class=\"font-medium\">Stable:</span> Preserves the relative order of equal elements.</li>",
            "  <li><span class=\"font-medium\">Predictable Performance:</span> O(n log n) time complexity in all cases.</li>",
            "  <li><span class=\"font-medium\">Not In-place:</span> Requires additional memory proportional to the input size.</li>",
            "  <li><span class=\"font-medium\">Parallelizable:</span> Can be parallelized effectively for large datasets.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li><strong>Divide:</strong> Split the unsorted array into two halves</li>",
            "    <li><strong>Conquer:</strong> Recursively sort both halves</li>",
            "    <li><strong>Merge:</strong> Merge the sorted halves to produce a single sorted array",
            "      <ul class=\"list-disc pl-6 mt-1\">",
            "        <li>Create a temporary array to store the merged result</li>",
            "        <li>Compare elements from both halves, selecting the smaller one</li>",
            "        <li>Add the selected element to the temporary array</li>",
            "        <li>Repeat until all elements from both halves are processed</li>",
            "        <li>Copy the temporary array back to the original array</li>",
            "      </ul>",
            "    </li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>The algorithm recursively divides the array until each subarray contains a single element, then merges them back together in sorted order:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original: [38, 27, 43, 3, 9, 82, 10]<br/><br/>",
            "    Divide: [38, 27, 43, 3] and [9, 82, 10]<br/>",
            "    Divide: [38, 27] and [43, 3] and [9, 82] and [10]<br/>",
            "    Divide: [38] and [27] and [43] and [3] and [9] and [82] and [10]<br/><br/>",
            "    Merge: [27, 38] and [3, 43] and [9, 82] and [10]<br/>",
            "    Merge: [3, 27, 38, 43] and [9, 10, 82]<br/>",
            "    Merge: [3, 9, 10, 27, 38, 43, 82]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n log n) - even when array is already sorted</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O(n log n) - consistent performance</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n log n) - guaranteed upper bound</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(n) - requires temporary array for merging</li>",
            "</ul>",
            "<p>Merge Sort is widely used because:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It guarantees O(n log n) time complexity regardless of the input data</li>",
            "  <li>It's well-suited for linked lists (requires only O(1) extra space)</li>",
            "  <li>It's stable, maintaining the order of equal elements</li>",
            "  <li>It's used in external sorting when data doesn't fit in memory</li>",
            "  <li>It forms the basis for other algorithms like Tim Sort</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure mergeSort(A: list of sortable items)",
            "    if length(A) ≤ 1 then",
            "        return A",
            "    end if",
            "    mid := length(A)/2",
            "    left := mergeSort(A[0...mid-1])",
            "    right := mergeSort(A[mid...length(A)-1])",
            "    return merge(left, right)",
            "end procedure",
            "",
            "procedure merge(left, right: list of sortable items)",
            "    result := []",
            "    while left.length > 0 and right.length > 0 do",
            "        if left[0] ≤ right[0] then",
            "            append left[0] to result",
            "            left := left[1...left.length-1]",
            "        else",
            "            append right[0] to result",
            "            right := right[1...right.length-1]",
            "        end if",
            "    end while",
            "    append remaining elements of left to result",
            "    append remaining elements of right to result",
            "    return result",
            "end procedure"
          ],
          "visualizationSteps": [
            "Divide array into two halves",
            "Recursively sort both halves",
            "Merge sorted halves",
            "Compare elements and place in correct order",
            "Continue until entire array is sorted"
          ]
        },
        {
          "id": "quick-sort",
          "name": "Quick Sort",
          "description": "Selects a 'pivot' element and partitions the array around it, recursively sorting the sub-arrays.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n log n)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(log n)",
          "howItWorks": [
            "<p>Quick Sort is an efficient divide-and-conquer sorting algorithm that selects a 'pivot' element and partitions the array around this pivot, recursively sorting the resulting sub-arrays:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Divide and Conquer:</span> Breaks down the problem into smaller parts.</li>",
            "  <li><span class=\"font-medium\">In-place:</span> Requires small additional space regardless of array size.</li>",
            "  <li><span class=\"font-medium\">Efficient:</span> Average case performance is excellent.</li>",
            "  <li><span class=\"font-medium\">Unstable:</span> May change the relative order of equal elements.</li>",
            "  <li><span class=\"font-medium\">Pivot Selection:</span> Performance heavily depends on pivot choice.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li><strong>Choose a pivot:</strong> Select an element from the array (commonly first, last, or middle element)</li>",
            "    <li><strong>Partition:</strong> Rearrange the array so that:",
            "      <ul class=\"list-disc pl-6 mt-1\">",
            "        <li>Elements less than the pivot come before the pivot</li>",
            "        <li>Elements greater than the pivot come after the pivot</li>",
            "        <li>The pivot is in its final sorted position</li>",
            "      </ul>",
            "    </li>",
            "    <li><strong>Recursively sort:</strong> Apply Quick Sort to both subarrays (elements before and after the pivot)</li>",
            "    <li><strong>Combine:</strong> The subarrays are already in their correct positions, so no additional combining step is needed</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>The algorithm partitions the array around pivots, ensuring each pivot finds its final position:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original: [10, 7, 8, 9, 1, 5]<br/>",
            "    Choose last element as pivot (5)<br/><br/>",
            "    Partition phase:<br/>",
            "    [1, 7, 8, 9, 10, 5] → Move elements less than 5 to left<br/>",
            "    [1, 5, 8, 9, 10, 7] → Place pivot in its correct position<br/><br/>",
            "    Recursively sort left subarray [1] (already sorted)<br/>",
            "    Recursively sort right subarray [8, 9, 10, 7]<br/>",
            "    - Choose pivot (7)<br/>",
            "    - After partition: [7, 8, 9, 10]<br/>",
            "    - Continue recursion...<br/><br/>",
            "    Final sorted array: [1, 5, 7, 8, 9, 10]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n log n) - when partitions are balanced</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O(n log n) - with random pivot selection</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n²) - when pivots create highly unbalanced partitions</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(log n) - for recursion stack in average case, O(n) in worst case</li>",
            "</ul>",
            "<p>Quick Sort's advantages include:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It's often faster in practice than other O(n log n) algorithms</li>",
            "  <li>It has good cache performance and works well with virtual memory</li>",
            "  <li>It can be optimized through intelligent pivot selection (median-of-three, random)</li>",
            "  <li>It's in-place, requiring minimal extra memory</li>",
            "  <li>Modern implementations use hybrid approaches (combining with insertion sort for small subarrays)</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure quickSort(A: list of sortable items, low, high: indices)",
            "    if low < high then",
            "        pivot := partition(A, low, high)",
            "        quickSort(A, low, pivot - 1)",
            "        quickSort(A, pivot + 1, high)",
            "    end if",
            "end procedure",
            "",
            "procedure partition(A: list of sortable items, low, high: indices)",
            "    pivot := A[high]",
            "    i := low - 1",
            "    for j := low to high - 1 do",
            "        if A[j] ≤ pivot then",
            "            i := i + 1",
            "            swap(A[i], A[j])",
            "        end if",
            "    end for",
            "    swap(A[i + 1], A[high])",
            "    return i + 1",
            "end procedure"
          ],
          "visualizationSteps": [
            "Select a pivot element",
            "Partition array around pivot",
            "Place elements smaller than pivot before it",
            "Place elements greater than pivot after it",
            "Recursively sort both partitions"
          ]
        },
        {
          "id": "heap-sort",
          "name": "Heap Sort",
          "description": "Uses a binary heap data structure to sort elements.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n log n)",
            "worst": "O(n log n)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<p>Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements by first building a max heap, then extracting elements one by one in decreasing order:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Heap-based:</span> Uses a binary heap data structure.</li>",
            "  <li><span class=\"font-medium\">In-place:</span> Sorts the array with O(1) extra space.</li>",
            "  <li><span class=\"font-medium\">Unstable:</span> May change the relative order of equal elements.</li>",
            "  <li><span class=\"font-medium\">Guaranteed Efficiency:</span> Always performs in O(n log n) time.</li>",
            "  <li><span class=\"font-medium\">No Recursion:</span> Can be implemented without recursive calls.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li><strong>Build Max Heap:</strong> Convert the array into a max heap structure",
            "      <ul class=\"list-disc pl-6 mt-1\">",
            "        <li>Start from the last non-leaf node and heapify downward</li>",
            "        <li>Continue the process for all nodes up to the root</li>",
            "      </ul>",
            "    </li>",
            "    <li><strong>Extract Elements:</strong> Repeatedly extract the maximum element",
            "      <ul class=\"list-disc pl-6 mt-1\">",
            "        <li>Swap the root (maximum) with the last element</li>",
            "        <li>Reduce the heap size by 1</li>",
            "        <li>Heapify the root to maintain the max heap property</li>",
            "      </ul>",
            "    </li>",
            "    <li>After all elements are extracted, the array is sorted in ascending order</li>",
            "  </ol>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Heapify Process</h4>",
            "<div class=\"pl-4\">",
            "  <p>Heapify is the process of converting a binary tree into a heap. For a max heap:</p>",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Compare the current node with its children</li>",
            "    <li>If the largest of the three is not the current node, swap with the largest child</li>",
            "    <li>Continue this process downward until the node is larger than both its children or becomes a leaf node</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>The algorithm first builds a max heap, then repeatedly extracts the maximum element:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original: [4, 10, 3, 5, 1]<br/><br/>",
            "    Building max heap:<br/>",
            "    Starting tree: [4, 10, 3, 5, 1]<br/>",
            "    After heapifying node at index 1: [4, 10, 3, 5, 1]<br/>",
            "    After heapifying node at index 0: [10, 5, 3, 4, 1] (max heap)<br/><br/>",
            "    Extracting elements:<br/>",
            "    Swap 10 and 1: [1, 5, 3, 4, 10]<br/>",
            "    Heapify from root: [5, 4, 3, 1, 10]<br/>",
            "    Swap 5 and 1: [1, 4, 3, 5, 10]<br/>",
            "    Heapify from root: [4, 1, 3, 5, 10]<br/>",
            "    Continue process...<br/><br/>",
            "    Final sorted array: [1, 3, 4, 5, 10]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n log n) - even with already sorted data</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O(n log n) - consistent performance</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n log n) - guaranteed upper bound</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(1) - in-place sorting</li>",
            "</ul>",
            "<p>Heap Sort advantages include:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It has a guaranteed O(n log n) time complexity even in worst cases</li>",
            "  <li>It doesn't require additional memory beyond the input array</li>",
            "  <li>It's efficient for large datasets where QuickSort might degrade to O(n²)</li>",
            "  <li>It's useful in priority queue implementations</li>",
            "  <li>It's relatively simple to implement compared to other efficient sorting algorithms</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure heapSort(A: list of sortable items)",
            "    buildMaxHeap(A)",
            "    for i := length(A) - 1 downto 0 do",
            "        swap(A[0], A[i])",
            "        heapify(A, 0, i)",
            "    end for",
            "end procedure",
            "",
            "procedure buildMaxHeap(A: list of sortable items)",
            "    for i := floor(length(A)/2) downto 0 do",
            "        heapify(A, i, length(A))",
            "    end for",
            "end procedure",
            "",
            "procedure heapify(A: list of sortable items, i: index, size: integer)",
            "    left := 2*i + 1",
            "    right := 2*i + 2",
            "    largest := i",
            "    if left < size and A[left] > A[largest] then",
            "        largest := left",
            "    end if",
            "    if right < size and A[right] > A[largest] then",
            "        largest := right",
            "    end if",
            "    if largest ≠ i then",
            "        swap(A[i], A[largest])",
            "        heapify(A, largest, size)",
            "    end if",
            "end procedure"
          ],
          "visualizationSteps": [
            "Build a max heap from the array",
            "Swap the root (maximum element) with the last element",
            "Reduce heap size by one",
            "Heapify the root element",
            "Repeat until heap size becomes one"
          ]
        },
        {
          "id": "radix-sort",
          "name": "Radix Sort",
          "description": "Sorts integers by processing individual digits.",
          "timeComplexity": {
            "best": "O(nk)",
            "average": "O(nk)",
            "worst": "O(nk)"
          },
          "spaceComplexity": "O(n+k)",
          "howItWorks": [
            "<p>Radix Sort is a non-comparative integer sorting algorithm that sorts data by processing individual digits, working from the least significant digit (LSD) to the most significant digit (MSD):</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Digit-by-Digit Processing:</span> Sorts numbers by examining one digit position at a time.</li>",
            "  <li><span class=\"font-medium\">Stable Sort:</span> Maintains the relative order of records with equal keys.</li>",
            "  <li><span class=\"font-medium\">Linear Time:</span> Achieves O(nk) time complexity where k is the number of digits.</li>",
            "  <li><span class=\"font-medium\">Non-Comparative:</span> Doesn't compare elements directly against each other.</li>",
            "  <li><span class=\"font-medium\">Counting Sort Based:</span> Typically uses counting sort as a subroutine for each digit position.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Find the maximum number to determine the number of digits</li>",
            "    <li>For each digit position, starting from the least significant digit (rightmost):",
            "      <ul class=\"list-disc pl-6 mt-1\">",
            "        <li>Sort the array based on the current digit position using a stable sorting algorithm (usually counting sort)</li>",
            "        <li>The stability of the sort ensures that if two elements have the same digit at the current position, their relative order from the previous steps is preserved</li>",
            "      </ul>",
            "    </li>",
            "    <li>Repeat the process for each digit position, moving toward the most significant digit (leftmost)</li>",
            "    <li>After processing all digit positions, the array is fully sorted</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>Let's sort the array [170, 45, 75, 90, 802, 24, 2, 66] using Radix Sort:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original: [170, 45, 75, 90, 802, 24, 2, 66]<br/><br/>",
            "    <span class=\"font-medium\">First pass: Sort by the 1's digit (least significant digit)</span><br/>",
            "    [170, 90, 802, 2, 24, 45, 75, 66] → Elements grouped by their last digit (0, 0, 2, 2, 4, 5, 5, 6)<br/><br/>",
            "    <span class=\"font-medium\">Second pass: Sort by the 10's digit</span><br/>",
            "    [802, 2, 24, 45, 66, 170, 75, 90] → Elements grouped by their second-last digit (0, 0, 2, 4, 6, 7, 7, 9)<br/><br/>",
            "    <span class=\"font-medium\">Third pass: Sort by the 100's digit (most significant digit for this array)</span><br/>",
            "    [2, 24, 45, 66, 75, 90, 170, 802] → Elements grouped by their third-last digit (0, 0, 0, 0, 0, 0, 1, 8)<br/><br/>",
            "    Final sorted array: [2, 24, 45, 66, 75, 90, 170, 802]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span> O(nk) where n is the number of elements and k is the number of digits in the maximum element</li>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(n+k) where k is the range of input (typically 10 for decimal digits)</li>",
            "</ul>",
            "<p>Radix Sort advantages include:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It can be faster than O(n log n) comparison-based sorts for integers with a limited number of digits</li>",
            "  <li>It's stable, preserving the relative order of elements with equal keys</li>",
            "  <li>It's particularly effective for sorting fixed-length integers like social security numbers, phone numbers, or ZIP codes</li>",
            "  <li>It can be extended to sort strings lexicographically</li>",
            "</ul>",
            "<p>Limitations:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It's primarily designed for integers (though can be adapted for strings and floating-point numbers)</li>",
            "  <li>Requires extra space for the counting sort procedure at each pass</li>",
            "  <li>May not be efficient for very large ranges of values or when k is large</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure radixSort(A: list of integers)",
            "    max := maximum value in A",
            "    for exp := 1 to max/exp > 0 do exp *= 10",
            "        countingSort(A, exp)",
            "    end for",
            "end procedure",
            "",
            "procedure countingSort(A: list of integers, exp: integer)",
            "    output[n] := new array of size n",
            "    count[10] := new array of size 10 initialized to 0",
            "    for i := 0 to n-1 do",
            "        index := (A[i] / exp) mod 10",
            "        count[index]++",
            "    end for",
            "    for i := 1 to 9 do",
            "        count[i] += count[i-1]",
            "    end for",
            "    for i := n-1 downto 0 do",
            "        index := (A[i] / exp) mod 10",
            "        output[count[index] - 1] := A[i]",
            "        count[index]--",
            "    end for",
            "    for i := 0 to n-1 do",
            "        A[i] := output[i]",
            "    end for",
            "end procedure"
          ],
          "visualizationSteps": [
            "Sort numbers by their least significant digit",
            "Sort again by the next digit to the left",
            "Continue until all digits are processed",
            "Maintain relative order of elements with same digit (stable sort)",
            "Result is a fully sorted array"
          ]
        },
        {
          "id": "counting-sort",
          "name": "Counting Sort",
          "description": "Counts occurrences of each element and reconstructs the sorted array.",
          "timeComplexity": {
            "best": "O(n+k)",
            "average": "O(n+k)",
            "worst": "O(n+k)"
          },
          "spaceComplexity": "O(n+k)",
          "howItWorks": [
            "<p>Counting Sort is a non-comparative sorting algorithm that works by counting the number of occurrences of each distinct element in the input array and using that information to place elements in their correct sorted positions:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Non-Comparative:</span> Doesn't compare elements to each other.</li>",
            "  <li><span class=\"font-medium\">Linear Time:</span> Achieves O(n+k) time complexity where k is the range of input.</li>",
            "  <li><span class=\"font-medium\">Stable:</span> Preserves the relative order of equal elements.</li>",
            "  <li><span class=\"font-medium\">Integer-based:</span> Primarily used for sorting integers within a specific range.</li>",
            "  <li><span class=\"font-medium\">Auxiliary Space:</span> Requires additional space proportional to the range of input values.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Find the range of input elements (minimum to maximum value)</li>",
            "    <li>Create a counting array of size equal to the range, initialized to zeros</li>",
            "    <li>Count each element in the input array by incrementing the corresponding index in the counting array</li>",
            "    <li>Modify the counting array to store cumulative counts (each position contains the count of elements less than or equal to that index)</li>",
            "    <li>Create an output array of the same size as the input array</li>",
            "    <li>Place each element from the input array into its correct sorted position in the output array using the counting array</li>",
            "    <li>Copy the sorted elements from the output array back to the input array (if needed)</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>Let's sort the array [4, 2, 2, 8, 3, 3, 1] using Counting Sort:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original array: [4, 2, 2, 8, 3, 3, 1]<br/><br/>",
            "    <span class=\"font-medium\">Step 1: Create a counting array</span><br/>",
            "    Count[0...8] = [0, 0, 0, 0, 0, 0, 0, 0, 0]<br/><br/>",
            "    <span class=\"font-medium\">Step 2: Count the occurrences of each element</span><br/>",
            "    Count[1] = 1 (1 occurs once)<br/>",
            "    Count[2] = 2 (2 occurs twice)<br/>",
            "    Count[3] = 2 (3 occurs twice)<br/>",
            "    Count[4] = 1 (4 occurs once)<br/>",
            "    Count[8] = 1 (8 occurs once)<br/>",
            "    Count array: [0, 1, 2, 2, 1, 0, 0, 0, 1]<br/><br/>",
            "    <span class=\"font-medium\">Step 3: Calculate cumulative counts</span><br/>",
            "    Count[0] = 0<br/>",
            "    Count[1] = 0 + 1 = 1<br/>",
            "    Count[2] = 1 + 2 = 3<br/>",
            "    Count[3] = 3 + 2 = 5<br/>",
            "    Count[4] = 5 + 1 = 6<br/>",
            "    Count[5] = 6 + 0 = 6<br/>",
            "    Count[6] = 6 + 0 = 6<br/>",
            "    Count[7] = 6 + 0 = 6<br/>",
            "    Count[8] = 6 + 1 = 7<br/>",
            "    Cumulative count array: [0, 1, 3, 5, 6, 6, 6, 6, 7]<br/><br/>",
            "    <span class=\"font-medium\">Step 4: Build the output array</span><br/>",
            "    Process 1 (last element): Place at position Count[1]-1 = 0; Decrement Count[1]<br/>",
            "    Process 3: Place at position Count[3]-1 = 4; Decrement Count[3]<br/>",
            "    Process 3: Place at position Count[3]-1 = 3; Decrement Count[3]<br/>",
            "    Process 8: Place at position Count[8]-1 = 6; Decrement Count[8]<br/>",
            "    Process 2: Place at position Count[2]-1 = 2; Decrement Count[2]<br/>",
            "    Process 2: Place at position Count[2]-1 = 1; Decrement Count[2]<br/>",
            "    Process 4: Place at position Count[4]-1 = 5; Decrement Count[4]<br/><br/>",
            "    Final sorted array: [1, 2, 2, 3, 3, 4, 8]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span> O(n+k) where n is the number of elements and k is the range of input</li>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(n+k) for the counting array and output array</li>",
            "</ul>",
            "<p>Counting Sort advantages include:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It's efficient when the range of input values (k) is not significantly larger than the number of elements (n)</li>",
            "  <li>It achieves linear time complexity, outperforming comparison-based sorts for suitable datasets</li>",
            "  <li>It's stable, preserving the relative order of equal elements</li>",
            "  <li>It forms the basis for other sorting algorithms like Radix Sort</li>",
            "</ul>",
            "<p>Limitations:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>It's inefficient when the range of input values is large compared to the number of elements</li>",
            "  <li>It only works for discrete values (typically integers)</li>",
            "  <li>It requires additional space proportional to the range of input values</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure countingSort(A: list of integers, k: maximum value)",
            "    count[0...k] := new array of size k+1 initialized to 0",
            "    output[0...n-1] := new array of size n",
            "    for i := 0 to n-1 do",
            "        count[A[i]] := count[A[i]] + 1",
            "    end for",
            "    for i := 1 to k do",
            "        count[i] := count[i] + count[i-1]",
            "    end for",
            "    for i := n-1 downto 0 do",
            "        output[count[A[i]]-1] := A[i]",
            "        count[A[i]] := count[A[i]] - 1",
            "    end for",
            "    for i := 0 to n-1 do",
            "        A[i] := output[i]",
            "    end for",
            "end procedure"
          ],
          "visualizationSteps": [
            "Count the occurrences of each element",
            "Calculate cumulative count to determine position",
            "Place each element in its correct position in output array",
            "Copy the output array back to the original array",
            "Result is a fully sorted array"
          ]
        },
        {
          "id": "bucket-sort",
          "name": "Bucket Sort",
          "description": "Distributes elements into buckets and sorts each bucket individually.",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(n)",
          "howItWorks": [
            "<p>Bucket Sort is a distribution sorting algorithm that distributes elements into a number of buckets, sorts each bucket individually, and then concatenates the buckets to form the final sorted array:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Distribution-based:</span> Sorts by distributing elements into buckets based on their values.</li>",
            "  <li><span class=\"font-medium\">Hybrid algorithm:</span> Uses another sorting algorithm (often insertion sort) to sort individual buckets.</li>",
            "  <li><span class=\"font-medium\">Efficient for uniform data:</span> Performs best when input is uniformly distributed across the range.</li>",
            "  <li><span class=\"font-medium\">Linear time average case:</span> Achieves O(n) time complexity on average with appropriate conditions.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Create n empty buckets (where n is the number of elements to be sorted)</li>",
            "    <li>Distribute the elements into buckets based on their values:</li>",
            "    <ul class=\"list-disc pl-6 ml-6 mb-2\">",
            "      <li>For an element x, it's placed in bucket[n*x]</li>",
            "      <li>This mapping assumes values are in the range [0,1) or can be scaled to that range</li>",
            "    </ul>",
            "    <li>Sort each non-empty bucket individually (typically using insertion sort)</li>",
            "    <li>Concatenate all buckets in order to get the final sorted array</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>Let's sort the array [0.42, 0.32, 0.93, 0.25, 0.47, 0.01, 0.78] using Bucket Sort:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original array: [0.42, 0.32, 0.93, 0.25, 0.47, 0.01, 0.78]<br/><br/>",
            "    <span class=\"font-medium\">Step 1: Create 7 empty buckets (same as array length)</span><br/>",
            "    Bucket 0: []<br/>",
            "    Bucket 1: []<br/>",
            "    Bucket 2: []<br/>",
            "    Bucket 3: []<br/>",
            "    Bucket 4: []<br/>",
            "    Bucket 5: []<br/>",
            "    Bucket 6: []<br/><br/>",
            "    <span class=\"font-medium\">Step 2: Place each element in appropriate bucket (index = floor(7 * value))</span><br/>",
            "    0.42 → Bucket 2 (floor(7 * 0.42) = 2)<br/>",
            "    0.32 → Bucket 2 (floor(7 * 0.32) = 2)<br/>",
            "    0.93 → Bucket 6 (floor(7 * 0.93) = 6)<br/>",
            "    0.25 → Bucket 1 (floor(7 * 0.25) = 1)<br/>",
            "    0.47 → Bucket 3 (floor(7 * 0.47) = 3)<br/>",
            "    0.01 → Bucket 0 (floor(7 * 0.01) = 0)<br/>",
            "    0.78 → Bucket 5 (floor(7 * 0.78) = 5)<br/><br/>",
            "    Resulting buckets:<br/>",
            "    Bucket 0: [0.01]<br/>",
            "    Bucket 1: [0.25]<br/>",
            "    Bucket 2: [0.42, 0.32]<br/>",
            "    Bucket 3: [0.47]<br/>",
            "    Bucket 4: []<br/>",
            "    Bucket 5: [0.78]<br/>",
            "    Bucket 6: [0.93]<br/><br/>",
            "    <span class=\"font-medium\">Step 3: Sort each bucket (using insertion sort)</span><br/>",
            "    Bucket 0: [0.01] (already sorted)<br/>",
            "    Bucket 1: [0.25] (already sorted)<br/>",
            "    Bucket 2: [0.32, 0.42] (sorted)<br/>",
            "    Bucket 3: [0.47] (already sorted)<br/>",
            "    Bucket 4: [] (empty)<br/>",
            "    Bucket 5: [0.78] (already sorted)<br/>",
            "    Bucket 6: [0.93] (already sorted)<br/><br/>",
            "    <span class=\"font-medium\">Step 4: Concatenate all buckets</span><br/>",
            "    Final sorted array: [0.01, 0.25, 0.32, 0.42, 0.47, 0.78, 0.93]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span></li>",
            "  <ul class=\"list-circle pl-6 ml-6\">",
            "    <li>Best Case: O(n) when data is uniformly distributed</li>",
            "    <li>Average Case: O(n) with uniformly distributed data</li>",
            "    <li>Worst Case: O(n²) if all elements are placed in a single bucket</li>",
            "  </ul>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(n) for the buckets</li>",
            "</ul>",
            "<p>Bucket Sort advantages include:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Linear time complexity when data is uniformly distributed</li>",
            "  <li>Good for floating-point numbers between 0 and 1</li>",
            "  <li>Can be parallelized since each bucket can be sorted independently</li>",
            "  <li>Simple implementation when the input distribution is known</li>",
            "</ul>",
            "<p>Limitations:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Inefficient when data is not uniformly distributed</li>",
            "  <li>Requires appropriate selection of the bucket size and count</li>",
            "  <li>Additional overhead for managing the buckets</li>",
            "  <li>Not an in-place sorting algorithm</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure bucketSort(A: list of sortable items)",
            "    n := length(A)",
            "    create array of n empty buckets",
            "    for i := 0 to n-1 do",
            "        insert A[i] into bucket[n*A[i]]",
            "    end for",
            "    for i := 0 to n-1 do",
            "        sort bucket[i] using insertion sort",
            "    end for",
            "    concatenate all buckets into A",
            "end procedure"
          ],
          "visualizationSteps": [
            "Create empty buckets",
            "Distribute elements into appropriate buckets",
            "Sort individual buckets using another sorting algorithm",
            "Concatenate all sorted buckets",
            "Result is a fully sorted array"
          ]
        },
        {
          "id": "shell-sort",
          "name": "Shell Sort",
          "description": "Generalization of insertion sort that allows the exchange of items that are far apart.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n log² n)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<p>Shell Sort is an efficient sorting algorithm and a generalization of insertion sort that allows the exchange of items that are far apart. The algorithm gets its name from its inventor, Donald Shell.</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">In-place sorting:</span> Sorts the array with minimal extra space.</li>",
            "  <li><span class=\"font-medium\">Adaptive algorithm:</span> Performs better on partially sorted arrays.</li>",
            "  <li><span class=\"font-medium\">Extension of insertion sort:</span> Uses a varying gap sequence to overcome insertion sort's weakness on widely positioned elements.</li>",
            "  <li><span class=\"font-medium\">Unstable sort:</span> Does not guarantee that elements with the same value maintain their relative order.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Core Concept</h4>",
            "<p>The key idea behind Shell Sort is to rearrange the array to give it the property that taking every <i>h</i>th element (for some integer <i>h</i>, called the 'gap' or 'interval') yields a sorted subsequence. Such an array is called <i>h</i>-sorted.</p>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Start with a large gap value</li>",
            "    <li>Sort elements that are 'gap' distance apart using insertion sort</li>",
            "    <li>Reduce the gap and repeat until the gap becomes 1</li>",
            "    <li>When gap = 1, perform a standard insertion sort (the array is now partially sorted, making insertion sort efficient)</li>",
            "  </ol>",
            "</div>",
            "<p class=\"mt-2\">The key benefit is that elements can move long distances in the array with fewer comparisons and swaps than in bubble or insertion sort, efficiently handling the \"turtle problem\" (small values near the end of the array).</p>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Gap Sequences</h4>",
            "<p>The performance of Shell Sort heavily depends on the gap sequence used. Common sequences include:</p>",
            "<ul class=\"list-disc pl-6 ml-4 mb-2\">",
            "  <li>Shell's original sequence: N/2, N/4, ..., 1</li>",
            "  <li>Knuth's sequence: 1, 4, 13, 40, 121, ... (3ᵏ - 1)/2</li>",
            "  <li>Hibbard's sequence: 1, 3, 7, 15, 31, ... (2ᵏ - 1)</li>",
            "  <li>Sedgewick's sequence: 1, 8, 23, 77, 281, ... combinations of 4ⁱ + 3·2ʲ + 1</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>Let's sort the array [9, 8, 3, 7, 5, 6, 4, 1] using Shell Sort with gap sequence [4, 2, 1]:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original array: [9, 8, 3, 7, 5, 6, 4, 1]<br/><br/>",
            "    <span class=\"font-medium\">Pass 1: Gap = 4</span><br/>",
            "    Compare and sort elements that are 4 positions apart:<br/>",
            "    Subarrays: [9, 5], [8, 6], [3, 4], [7, 1]<br/><br/>",
            "    Sort [9, 5] → [5, 9]<br/>",
            "    Sort [8, 6] → [6, 8]<br/>",
            "    Sort [3, 4] → [3, 4] (already sorted)<br/>",
            "    Sort [7, 1] → [1, 7]<br/><br/>",
            "    Array after first pass: [5, 6, 3, 1, 9, 8, 4, 7]<br/><br/>",
            "    <span class=\"font-medium\">Pass 2: Gap = 2</span><br/>",
            "    Compare and sort elements that are 2 positions apart:<br/>",
            "    Subarrays: [5, 3, 9, 4], [6, 1, 8, 7]<br/><br/>",
            "    Sort [5, 3, 9, 4] → [3, 4, 5, 9]<br/>",
            "    Sort [6, 1, 8, 7] → [1, 6, 7, 8]<br/><br/>",
            "    Array after second pass: [3, 1, 4, 6, 5, 7, 9, 8]<br/><br/>",
            "    <span class=\"font-medium\">Pass 3: Gap = 1</span><br/>",
            "    This is just a standard insertion sort on the entire array:<br/>",
            "    [3, 1, 4, 6, 5, 7, 9, 8] → [1, 3, 4, 5, 6, 7, 8, 9]<br/><br/>",
            "    Final sorted array: [1, 3, 4, 5, 6, 7, 8, 9]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span></li>",
            "  <ul class=\"list-circle pl-6 ml-6\">",
            "    <li>Best Case: O(n log n) with optimal gap sequence</li>",
            "    <li>Average Case: O(n log² n) for many gap sequences</li>",
            "    <li>Worst Case: O(n²) with suboptimal gap sequence (like Shell's original)</li>",
            "  </ul>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(1) auxiliary space (in-place sorting)</li>",
            "</ul>",
            "<p>Shell Sort advantages include:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>More efficient than simple insertion sort for medium-sized arrays</li>",
            "  <li>In-place sorting algorithm requiring minimal extra memory</li>",
            "  <li>Practical for a wide range of input sizes</li>",
            "  <li>Excellent for nearly sorted arrays</li>",
            "  <li>Simple implementation compared to other efficient sorting algorithms</li>",
            "</ul>",
            "<p>Limitations:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Less efficient than quicksort, heapsort, or mergesort for large datasets</li>",
            "  <li>Unstable sort (equal elements may change their relative order)</li>",
            "  <li>Optimal gap sequence selection remains an open research problem</li>",
            "  <li>Performance heavily dependent on the chosen gap sequence</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure shellSort(A: list of sortable items)",
            "    n := length(A)",
            "    // Gap sequence can vary, this uses the simple n/2 sequence",
            "    gap := n/2",
            "    while gap > 0 do",
            "        for i := gap to n-1 do",
            "            temp := A[i]",
            "            j := i",
            "            while j >= gap and A[j-gap] > temp do",
            "                A[j] := A[j-gap]",
            "                j := j - gap",
            "            end while",
            "            A[j] := temp",
            "        end for",
            "        gap := gap/2",
            "    end while",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start with a large gap and sort elements that are far apart",
            "Progressively reduce the gap size",
            "Perform insertion sort on subarrays created by the gap",
            "Elements become partially sorted with each pass",
            "Final pass with gap=1 completes the sort (equivalent to insertion sort)"
          ]
        },
        {
          "id": "tim-sort",
          "name": "Tim Sort",
          "description": "A hybrid sorting algorithm derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data.",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n log n)",
            "worst": "O(n log n)"
          },
          "spaceComplexity": "O(n)",
          "howItWorks": [
            "<p>Tim Sort is a hybrid, stable sorting algorithm derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data. It was implemented by Tim Peters in 2002 for use in the Python programming language and is now used in several programming languages including Java, JavaScript, Swift, and Rust.</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Hybrid algorithm:</span> Combines merge sort and insertion sort to optimize performance.</li>",
            "  <li><span class=\"font-medium\">Stable sort:</span> Preserves the relative order of equal elements.</li>",
            "  <li><span class=\"font-medium\">Adaptive:</span> Takes advantage of existing order in the data.</li>",
            "  <li><span class=\"font-medium\">Real-world optimized:</span> Designed to work efficiently with actual data patterns found in applications.</li>",
            "  <li><span class=\"font-medium\">Memory efficient:</span> Uses optimizations to minimize temporary storage.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Core Concepts</h4>",
            "<p>Tim Sort is based on the observation that real-world data often contains partially ordered subsequences (called \"runs\"). The algorithm identifies these natural runs and merges them efficiently.</p>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Divide the array into blocks called runs</li>",
            "    <li>Identify natural runs (already sorted sequences) in the data</li>",
            "    <li>If a run is too small (less than minrun), extend it using insertion sort</li>",
            "    <li>Merge adjacent runs using a modified merge sort algorithm</li>",
            "    <li>Use galloping mode for merging when one run dominates another</li>",
            "  </ol>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Key Optimizations</h4>",
            "<ul class=\"list-disc pl-6 ml-4 mb-2\">",
            "  <li><span class=\"font-medium\">MinRun:</span> Small runs are extended to an efficient size (typically 16-64 elements)</li>",
            "  <li><span class=\"font-medium\">Run Identification:</span> Finds naturally occurring sorted sequences</li>",
            "  <li><span class=\"font-medium\">Galloping Mode:</span> When merging, if one run dominates, binary search is used to skip comparisons</li>",
            "  <li><span class=\"font-medium\">Merge Strategy:</span> Maintains a stack of runs and merges them according to specific rules</li>",
            "  <li><span class=\"font-medium\">Smart Merging:</span> Minimizes the number of comparisons during merges</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Explanation</h3>",
            "<p>Let's sort the array [5, 9, 10, 3, 2, 8, 7, 1, 4, 6, 11, 12] using Tim Sort:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    Original array: [5, 9, 10, 3, 2, 8, 7, 1, 4, 6, 11, 12]<br/><br/>",
            "    <span class=\"font-medium\">Step 1: Identify natural runs (assuming minrun = 4)</span><br/>",
            "    Natural runs: [5, 9, 10] and [11, 12]<br/>",
            "    Both runs are smaller than minrun (4)<br/><br/>",
            "    <span class=\"font-medium\">Step 2: Extend runs using insertion sort to reach minrun</span><br/>",
            "    First run: [5, 9, 10] + [3] → [3, 5, 9, 10] (extended to length 4)<br/>",
            "    Second run: [2, 8] (not a natural run, so form a run using insertion sort)<br/>",
            "    Third run: [7, 1, 4, 6] (not a natural run, so form a run using insertion sort) → [1, 4, 6, 7]<br/>",
            "    Fourth run: [11, 12] + [?] (need more elements, but none available, so leave as is)<br/><br/>",
            "    Current state: [3, 5, 9, 10], [2, 8], [1, 4, 6, 7], [11, 12]<br/><br/>",
            "    <span class=\"font-medium\">Step 3: Merge runs according to merging strategy rules</span><br/>",
            "    Merge [2, 8] and [1, 4, 6, 7] → [1, 2, 4, 6, 7, 8]<br/>",
            "    Current state: [3, 5, 9, 10], [1, 2, 4, 6, 7, 8], [11, 12]<br/><br/>",
            "    Merge [3, 5, 9, 10] and [1, 2, 4, 6, 7, 8] → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br/>",
            "    Current state: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [11, 12]<br/><br/>",
            "    Final merge: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] and [11, 12] → [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]<br/><br/>",
            "    Final sorted array: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Merge Strategy Rules</h3>",
            "<p>Tim Sort maintains balance in the merging process by ensuring these invariants:</p>",
            "<ul class=\"list-disc pl-6 mb-2\">",
            "  <li>X > Y + Z (where X, Y, Z are the lengths of the top three runs on the stack)</li>",
            "  <li>Y > Z</li>",
            "</ul>",
            "<p>If either invariant is violated, appropriate merges are performed to restore balance.</p>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span></li>",
            "  <ul class=\"list-circle pl-6 ml-6\">",
            "    <li>Best Case: O(n) when the array is already sorted</li>",
            "    <li>Average Case: O(n log n)</li>",
            "    <li>Worst Case: O(n log n) guaranteed</li>",
            "  </ul>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(n) auxiliary space</li>",
            "</ul>",
            "<p>Tim Sort advantages include:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Excellent performance on real-world data</li>",
            "  <li>Exploits existing order in the data</li>",
            "  <li>Guarantees O(n log n) worst-case performance</li>",
            "  <li>Stable sort that preserves the order of equal elements</li>",
            "  <li>Minimizes comparisons through various optimizations</li>",
            "  <li>Used in many programming language standard libraries</li>",
            "</ul>",
            "<p>Limitations:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>More complex implementation than other sorting algorithms</li>",
            "  <li>Requires O(n) auxiliary space, not an in-place algorithm</li>",
            "  <li>May not outperform specialized algorithms for certain data patterns</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure timSort(A: list of sortable items)",
            "    n := length(A)",
            "    RUN := determineBestRunSize()",
            "    // Sort individual subarrays of size RUN using insertion sort",
            "    for i := 0 to n-1 with step RUN do",
            "        insertionSort(A, i, min(i+RUN-1, n-1))",
            "    end for",
            "    // Start merging from size RUN",
            "    for size := RUN to n-1 with step 2*size do",
            "        for left := 0 to n-1 with step 2*size do",
            "            mid := min(n-1, left + size - 1)",
            "            right := min(left + 2*size - 1, n-1)",
            "            if mid < right then",
            "                merge(A, left, mid, right)",
            "            endif",
            "        end for",
            "    end for",
            "end procedure"
          ]
        }
      ]
    },
    {
      "id": "searching",
      "name": "Searching Algorithms",
      "description": "Algorithms that find the position of a target value within a data structure.",
      "algorithms": [
        {
          "id": "linear-search",
          "name": "Linear Search",
          "description": "A simple search algorithm that sequentially checks each element in a list until it finds the target value or reaches the end of the list.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<div class='space-y-4'>",
            "<p>Linear Search is the simplest searching algorithm that works by examining each element in a collection one-by-one until the target is found or the entire collection has been traversed.</p>",
            "<h3 class='font-semibold text-lg'>Key Features</h3>",
            "<ul class='list-disc pl-5 space-y-1'>",
            "<li>Examines elements sequentially without skipping</li>",
            "<li>No pre-processing or sorting required</li>",
            "<li>Works on any collection that allows element access</li>",
            "<li>Can terminate early upon finding the target</li>",
            "</ul>",
            "<h3 class='font-semibold text-lg'>Algorithm Steps</h3>",
            "<ol class='list-decimal pl-5 space-y-1'>",
            "<li>Start from the first element (index 0)</li>",
            "<li>Compare the current element with the target value</li>",
            "<li>If they match, return the current index</li>",
            "<li>If they don't match, move to the next element</li>",
            "<li>Repeat steps 2-4 until either the target is found or the end of the collection is reached</li>",
            "<li>If the end is reached without finding the target, return -1 (or another indicator that the target wasn't found)</li>",
            "</ol>",
            "<h3 class='font-semibold text-lg'>Visual Example</h3>",
            "<p>To find the value 7 in [3, 9, 4, 2, 7, 1]:</p>",
            "<ul class='list-disc pl-5 space-y-1'>",
            "<li>Check index 0: 3 ≠ 7 → move to next element</li>",
            "<li>Check index 1: 9 ≠ 7 → move to next element</li>",
            "<li>Check index 2: 4 ≠ 7 → move to next element</li>",
            "<li>Check index 3: 2 ≠ 7 → move to next element</li>",
            "<li>Check index 4: 7 = 7 → target found! Return index 4</li>",
            "</ul>",
            "<h3 class='font-semibold text-lg'>Performance Analysis</h3>",
            "<ul class='list-disc pl-5 space-y-1'>",
            "<li><strong>Best case:</strong> O(1) - when the target is at the first position</li>",
            "<li><strong>Average case:</strong> O(n/2) → O(n) - when the target is randomly positioned</li>",
            "<li><strong>Worst case:</strong> O(n) - when the target is at the last position or not present</li>",
            "</ul>",
            "<h3 class='font-semibold text-lg'>Advantages</h3>",
            "<ul class='list-disc pl-5 space-y-1'>",
            "<li>Simple and easy to implement</li>",
            "<li>Works on unsorted collections</li>",
            "<li>No additional memory required</li>",
            "<li>Efficient for small datasets</li>",
            "<li>Often used as a subroutine in more complex algorithms</li>",
            "</ul>",
            "<h3 class='font-semibold text-lg'>Limitations</h3>",
            "<ul class='list-disc pl-5 space-y-1'>",
            "<li>Inefficient for large datasets compared to algorithms like Binary Search</li>",
            "<li>No way to skip elements that are definitely not the target</li>",
            "<li>Linear time complexity means performance degrades linearly with collection size</li>",
            "</ul>",
            "</div>"
          ],
          "pseudocode": [
            "procedure linearSearch(A, target)",
            "    for i := 0 to length(A) - 1 do",
            "        if A[i] = target then",
            "            return i",
            "        end if",
            "    end for",
            "    return -1",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start at the first element of the array",
            "Compare the current element with the target value",
            "If the element matches the target, return the current position",
            "If the element doesn't match, move to the next element",
            "Repeat until the element is found or the end of the array is reached"
          ]
        },
        {
          "id": "binary-search",
          "name": "Binary Search",
          "description": "An efficient search algorithm that works on sorted arrays by repeatedly dividing the search interval in half.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(log n)",
            "worst": "O(log n)"
          },
          "spaceComplexity": "O(1)",
          "pseudocode": [
            "procedure binarySearch(A, target)",
            "    left := 0",
            "    right := length(A) - 1",
            "    while left ≤ right do",
            "        mid := (left + right) / 2",
            "        if A[mid] = target then",
            "            return mid",
            "        end if",
            "        if A[mid] < target then",
            "            left := mid + 1",
            "        else",
            "            right := mid - 1",
            "        end if",
            "    end while",
            "    return -1",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start with left pointer at the beginning and right pointer at the end of the sorted array",
            "Find the middle element between the left and right pointers",
            "If the middle element equals the target, return its position",
            "If the middle element is less than the target, move the left pointer to mid+1",
            "If the middle element is greater than the target, move the right pointer to mid-1",
            "Repeat until the element is found or the search space is empty"
          ]
        },
        {
          "id": "jump-search",
          "name": "Jump Search",
          "description": "A search algorithm for sorted arrays that jumps ahead by fixed steps and then performs linear search in the identified block.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(√n)",
            "worst": "O(√n)"
          },
          "spaceComplexity": "O(1)",
          "pseudocode": [
            "procedure jumpSearch(A, target)",
            "    step := √n",
            "    prev := 0",
            "    while A[min(step, n) - 1] < target do",
            "        prev := step",
            "        step += √n",
            "        if prev ≥ n then",
            "            return -1",
            "        end if",
            "    end while",
            "    while A[prev] < target do",
            "        prev += 1",
            "        if prev = min(step, n) then",
            "            return -1",
            "        end if",
            "    end while",
            "    if A[prev] = target then",
            "        return prev",
            "    end if",
            "    return -1",
            "end procedure"
          ],
          "visualizationSteps": [
            "Calculate the jump step size as the square root of the array length",
            "Jump ahead by the step size and check if the element at that position is greater than the target",
            "Continue jumping until finding a value greater than the target or reaching the end of the array",
            "Perform a linear search in the block where the target might be located",
            "Return the position if found, otherwise indicate the target is not in the array"
          ]
        },
        {
          "id": "fibonacci-search",
          "name": "Fibonacci Search",
          "description": "A search algorithm that uses Fibonacci numbers to divide the array into unequal parts, similar to binary search but with different division ratios.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(log n)",
            "worst": "O(log n)"
          },
          "spaceComplexity": "O(1)",
          "pseudocode": [
            "procedure fibonacciSearch(A, target)",
            "    fibM2 := 0",
            "    fibM1 := 1",
            "    fibM := fibM1 + fibM2",
            "    while fibM < length(A) do",
            "        fibM2 := fibM1",
            "        fibM1 := fibM",
            "        fibM := fibM1 + fibM2",
            "    end while",
            "    offset := -1",
            "    while fibM > 1 do",
            "        i := min(offset + fibM2, length(A) - 1)",
            "        if A[i] < target then",
            "            fibM := fibM1",
            "            fibM1 := fibM2",
            "            fibM2 := fibM - fibM1",
            "            offset := i",
            "        else if A[i] > target then",
            "            fibM := fibM2",
            "            fibM1 := fibM1 - fibM2",
            "            fibM2 := fibM - fibM1",
            "        else",
            "            return i",
            "        end if",
            "    end while",
            "    if fibM1 and A[offset + 1] = target then",
            "        return offset + 1",
            "    end if",
            "    return -1",
            "end procedure"
          ],
          "visualizationSteps": [
            "Generate Fibonacci numbers until finding one larger than the array length",
            "Use Fibonacci numbers to divide the search space",
            "Compare the target with the element at the calculated position",
            "Adjust the Fibonacci numbers to narrow the search range",
            "Continue until the target is found or the search space is exhausted"
          ]
        },
        {
          "id": "interpolation-search",
          "name": "Interpolation Search",
          "description": "An improved variant of binary search that uses the value of the target to estimate its position in the array.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(log log n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(1)",
          "pseudocode": [
            "procedure interpolationSearch(A, target)",
            "    low := 0",
            "    high := length(A) - 1",
            "    while low ≤ high and target ≥ A[low] and target ≤ A[high] do",
            "        if low = high then",
            "            if A[low] = target then",
            "                return low",
            "            end if",
            "            return -1",
            "        end if",
            "        pos := low + ((target - A[low]) * (high - low)) / (A[high] - A[low])",
            "        if A[pos] = target then",
            "            return pos",
            "        end if",
            "        if A[pos] < target then",
            "            low := pos + 1",
            "        else",
            "            high := pos - 1",
            "        end if",
            "    end while",
            "    return -1",
            "end procedure"
          ],
          "visualizationSteps": [
            "Initialize low and high pointers to the beginning and end of the array",
            "Estimate the position of the target using interpolation formula based on values",
            "If the element at the estimated position equals the target, return that position",
            "If the element is less than the target, adjust the low pointer",
            "If the element is greater than the target, adjust the high pointer",
            "Repeat until the target is found or the search space is empty"
          ]
        },
        {
          "id": "exponential-search",
          "name": "Exponential Search",
          "description": "A search algorithm that works on unbounded lists by finding a range where the target might be present and then performing binary search in that range.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(log i)",
            "worst": "O(log i)"
          },
          "spaceComplexity": "O(1)",
          "pseudocode": [
            "procedure exponentialSearch(A, target)",
            "    if A[0] = target then",
            "        return 0",
            "    end if",
            "    i := 1",
            "    while i < length(A) and A[i] ≤ target do",
            "        i := i * 2",
            "    end while",
            "    return binarySearch(A, i/2, min(i, length(A)), target)",
            "end procedure"
          ],
          "visualizationSteps": [
            "Check if the target is at the first position of the array",
            "Start with i = 1 and double it until A[i] exceeds the target",
            "This finds a range where the target might be located",
            "Perform binary search in the range from i/2 to min(i, array length)",
            "Return the position if found, otherwise indicate the target is not in the array"
          ]
        },
        {
          "id": "ternary-search",
          "name": "Ternary Search",
          "description": "A divide-and-conquer search algorithm that divides the search space into three parts and determines which part the target element is likely to be in.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(log n)",
            "worst": "O(log n)"
          },
          "spaceComplexity": "O(1)",
          "pseudocode": [
            "procedure ternarySearch(A, target, left, right)",
            "    if right >= left then",
            "        mid1 := left + (right - left) / 3",
            "        mid2 := right - (right - left) / 3",
            "        if A[mid1] = target then",
            "            return mid1",
            "        end if",
            "        if A[mid2] = target then",
            "            return mid2",
            "        end if",
            "        if target < A[mid1] then",
            "            return ternarySearch(A, target, left, mid1 - 1)",
            "        else if target > A[mid2] then",
            "            return ternarySearch(A, target, mid2 + 1, right)",
            "        else",
            "            return ternarySearch(A, target, mid1 + 1, mid2 - 1)",
            "        end if",
            "    end if",
            "    return -1",
            "end procedure"
          ],
          "visualizationSteps": [
            "Divide the search space into three equal parts using mid1 and mid2",
            "Compare the target with elements at both mid1 and mid2",
            "If the target matches either mid1 or mid2, return that position",
            "If the target is less than the element at mid1, search in the first part",
            "If the target is greater than the element at mid2, search in the third part",
            "Otherwise, search in the middle part between mid1 and mid2",
            "Repeat until the target is found or the search space is exhausted"
          ]
        }
      ]
    },
    {
      "id": "graph",
      "name": "Graph Algorithms",
      "description": "Algorithms that operate on graphs, which consist of vertices (nodes) and edges connecting these vertices.",
      "algorithms": [
        {
          "id": "bfs",
          "name": "Breadth-First Search (BFS)",
          "description": "Explores all neighbor nodes at the present depth before moving to nodes at the next depth level.",
          "timeComplexity": {
            "best": "O(V + E)",
            "average": "O(V + E)",
            "worst": "O(V + E)"
          },
          "spaceComplexity": "O(V)",
          "pseudocode": [
            "procedure BFS(G: graph, start: vertex)",
            "    let Q be a queue",
            "    label start as discovered",
            "    Q.enqueue(start)",
            "    while Q is not empty do",
            "        v := Q.dequeue()",
            "        for all edges from v to w in G.adjacentEdges(v) do",
            "            if w is not labeled as discovered then",
            "                label w as discovered",
            "                Q.enqueue(w)",
            "            end if",
            "        end for",
            "    end while",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start at a selected node",
            "Explore all neighbor nodes",
            "Mark visited nodes",
            "Use a queue to track nodes to visit",
            "Continue until all reachable nodes are visited"
          ]
        },
        {
          "id": "dfs",
          "name": "Depth-First Search (DFS)",
          "description": "Explores as far as possible along each branch before backtracking.",
          "timeComplexity": {
            "best": "O(V + E)",
            "average": "O(V + E)",
            "worst": "O(V + E)"
          },
          "spaceComplexity": "O(V)",
          "pseudocode": [
            "procedure DFS(G: graph, v: vertex)",
            "    label v as discovered",
            "    for all edges from v to w in G.adjacentEdges(v) do",
            "        if w is not labeled as discovered then",
            "            recursively call DFS(G, w)",
            "        end if",
            "    end for",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start at a selected node",
            "Explore as far as possible along one branch",
            "Mark visited nodes",
            "Backtrack when no unvisited neighbors",
            "Continue until all reachable nodes are visited"
          ]
        },
        {
          "id": "dijkstra",
          "name": "Dijkstra's Algorithm",
          "description": "Finds the shortest paths from a source vertex to all other vertices in a weighted graph.",
          "timeComplexity": {
            "best": "O((V + E) log V)",
            "average": "O((V + E) log V)",
            "worst": "O((V + E) log V)"
          },
          "spaceComplexity": "O(V)",
          "pseudocode": [
            "procedure Dijkstra(G: graph, start: vertex)",
            "    for each vertex v in G do",
            "        distance[v] := infinity",
            "        previous[v] := undefined",
            "        visited[v] := false",
            "    end for",
            "    distance[start] := 0",
            "    Q := set of all vertices in G",
            "    while Q is not empty do",
            "        u := vertex in Q with minimum distance[u]",
            "        if distance[u] = infinity then",
            "            break",
            "        end if",
            "        remove u from Q",
            "        visited[u] := true",
            "        for each neighbor v of u do",
            "            if not visited[v] then",
            "                alt := distance[u] + length(u, v)",
            "                if alt < distance[v] then",
            "                    distance[v] := alt",
            "                    previous[v] := u",
            "                end if",
            "            end if",
            "        end for",
            "    end while",
            "    return distance[], previous[]",
            "end procedure"
          ],
          "visualizationSteps": [
            "Set distance of start vertex to 0, all others to infinity",
            "Select unvisited vertex with minimum distance",
            "Mark selected vertex as visited",
            "Update distances to all unvisited neighbors",
            "Repeat until all vertices are visited or remaining vertices are unreachable"
          ]
        },
        {
          "id": "bellman-ford",
          "name": "Bellman-Ford Algorithm",
          "description": "Finds the shortest paths from a source vertex to all other vertices in a weighted graph, capable of handling negative weight edges.",
          "timeComplexity": {
            "best": "O(V·E)",
            "average": "O(V·E)",
            "worst": "O(V·E)"
          },
          "spaceComplexity": "O(V)",
          "pseudocode": [
            "procedure BellmanFord(G: graph, start: vertex)",
            "    for each vertex v in G do",
            "        distance[v] := infinity",
            "        previous[v] := undefined",
            "    end for",
            "    distance[start] := 0",
            "",
            "    // Relax all edges |V| - 1 times",
            "    for i := 1 to |V| - 1 do",
            "        for each edge (u, v) with weight w in G.edges do",
            "            if distance[u] + w < distance[v] then",
            "                distance[v] := distance[u] + w",
            "                previous[v] := u",
            "            end if",
            "        end for",
            "    end for",
            "",
            "    // Check for negative-weight cycles",
            "    for each edge (u, v) with weight w in G.edges do",
            "        if distance[u] + w < distance[v] then",
            "            return \"Graph contains a negative-weight cycle\"",
            "        end if",
            "    end for",
            "",
            "    return distance[], previous[]",
            "end procedure"
          ],
          "visualizationSteps": [
            "Initialize distances: set start vertex to 0, all others to infinity",
            "Perform |V| - 1 relaxation passes through all edges",
            "For each edge, check if path through it gives shorter distance",
            "Update distances and previous pointers when shorter paths found",
            "Check for negative weight cycles with one extra pass",
            "If any distance can still be reduced, a negative cycle exists"
          ]
        },
        {
          "id": "floyd-warshall",
          "name": "Floyd-Warshall Algorithm",
          "description": "Finds the shortest paths between all pairs of vertices in a weighted graph, with support for negative edge weights.",
          "timeComplexity": {
            "best": "O(V³)",
            "average": "O(V³)",
            "worst": "O(V³)"
          },
          "spaceComplexity": "O(V²)",
          "pseudocode": [
            "procedure FloydWarshall(G: graph with n vertices)",
            "    // Initialize distance matrix dist",
            "    let dist be a n×n matrix",
            "    for i := 1 to n do",
            "        for j := 1 to n do",
            "            if i = j then",
            "                dist[i][j] := 0",
            "            else if edge (i, j) exists in G then",
            "                dist[i][j] := weight of edge (i, j)",
            "            else",
            "                dist[i][j] := infinity",
            "            end if",
            "        end for",
            "    end for",
            "",
            "    // Main algorithm",
            "    for k := 1 to n do",
            "        for i := 1 to n do",
            "            for j := 1 to n do",
            "                if dist[i][j] > dist[i][k] + dist[k][j] then",
            "                    dist[i][j] := dist[i][k] + dist[k][j]",
            "                end if",
            "            end for",
            "        end for",
            "    end for",
            "",
            "    // Check for negative cycles",
            "    for i := 1 to n do",
            "        if dist[i][i] < 0 then",
            "            return \"Graph contains a negative cycle\"",
            "        end if",
            "    end for",
            "",
            "    return dist",
            "end procedure"
          ],
          "visualizationSteps": [
            "Initialize a distance matrix with direct edge weights",
            "For each vertex k as an intermediate vertex",
            "For each pair of vertices (i,j), check if path i→k→j is shorter than direct path i→j",
            "Update distance matrix with shortest paths found",
            "After processing all vertices, the matrix contains shortest paths between all pairs",
            "Check for negative cycles by examining if any vertex has negative distance to itself"
          ]
        },
        {
          "id": "kruskals",
          "name": "Kruskal's Algorithm",
          "description": "Finds a minimum spanning tree for a connected weighted graph by adding edges in order of increasing weight without creating cycles.",
          "timeComplexity": {
            "best": "O(E log E)",
            "average": "O(E log E)",
            "worst": "O(E log E)"
          },
          "spaceComplexity": "O(V + E)",
          "pseudocode": [
            "procedure Kruskal(G: graph)",
            "    A := ∅ // A will contain the edges of the MST",
            "    for each vertex v in G do",
            "        Make-Set(v) // Create a set for each vertex",
            "    end for",
            "    sort edges of G by weight in non-decreasing order",
            "    for each edge (u, v) in G, in non-decreasing order of weight do",
            "        if Find-Set(u) ≠ Find-Set(v) then",
            "            A := A ∪ {(u, v)}",
            "            Union(u, v)",
            "        end if",
            "    end for",
            "    return A",
            "end procedure"
          ],
          "visualizationSteps": [
            "Create a set for each vertex in the graph",
            "Sort all edges in non-decreasing order of their weight",
            "Consider edges in sorted order",
            "Add an edge if it doesn't create a cycle in the current MST",
            "Continue until V-1 edges are added, forming a complete MST",
            "Use Union-Find data structure to efficiently detect cycles"
          ]
        },
        {
          "id": "prims",
          "name": "Prim's Algorithm",
          "description": "A greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized.",
          "timeComplexity": {
            "best": "O(E log V)",
            "average": "O(E log V)",
            "worst": "O(E log V)"
          },
          "spaceComplexity": "O(V + E)",
          "pseudocode": [
            "function Prim(Graph, start):",
            "    Create a MinPriorityQueue pq",
            "    For each vertex v in Graph:",
            "        distance[v] = INFINITY",
            "        inMST[v] = false",
            "    distance[start] = 0",
            "    pq.add((0, start))",
            "    While pq is not empty:",
            "        u = pq.extractMin()",
            "        inMST[u] = true",
            "        For each neighbor v of u:",
            "            weight = edge_weight(u, v)",
            "            If inMST[v] is false AND weight < distance[v]:",
            "                distance[v] = weight",
            "                parent[v] = u",
            "                pq.add((distance[v], v))",
            "    Return MST using parent array"
          ],
          "visualizationSteps": [
            "Initialize a priority queue PQ to keep track of vertices and their minimum edge weights.",
            "Add the starting vertex to the MST and update the key values of adjacent vertices.",
            "Extract the vertex with the minimum key from PQ that is not yet in the MST.",
            "Add the extracted vertex to the MST.",
            "Update the key values of adjacent vertices if a cheaper connection is found.",
            "Repeat steps 3-5 until all vertices are included in the MST.",
            "The resulting tree is the Minimum Spanning Tree."
          ]
        },
        {
          "id": "topological-sort",
          "name": "Topological Sort",
          "description": "Produces a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u, v), vertex u comes before vertex v in the ordering.",
          "timeComplexity": {
            "best": "O(V + E)",
            "average": "O(V + E)",
            "worst": "O(V + E)"
          },
          "spaceComplexity": "O(V)",
          "pseudocode": [
            "function TopologicalSort(Graph):",
            "    L := Empty list that will contain the sorted vertices",
            "    S := Set of all vertices with no incoming edges (in-degree zero)",
            "    while S is not empty do",
            "        remove a vertex n from S",
            "        add n to the end of L",
            "        for each vertex m with an edge e from n to m do",
            "            remove edge e from the graph",
            "            if m has no other incoming edges then",
            "                insert m into S",
            "    if graph has edges then",
            "        return error (graph has at least one cycle)",
            "    else",
            "        return L (a topologically sorted order)"
          ],
          "visualizationSteps": [
            "Identify all vertices with no incoming edges (in-degree zero) and add them to a queue.",
            "Remove a vertex from the queue and add it to the result list.",
            "For each neighbor of the removed vertex, remove the edge connecting them.",
            "If a neighbor now has in-degree zero, add it to the queue.",
            "Repeat steps 2-4 until the queue is empty.",
            "If all vertices are in the result list, return the list as the topological order.",
            "If vertices remain with edges, then the graph has at least one cycle and topological sorting is not possible."
          ]
        },
        {
          "id": "johnsons",
          "name": "Johnson's Algorithm",
          "description": "Finds all-pairs shortest paths in a sparse directed graph with positive or negative edge weights (but no negative cycles). It combines elements of both Dijkstra's and Bellman-Ford algorithms for better performance on sparse graphs.",
          "timeComplexity": {
            "best": "O(V² log V + VE)",
            "average": "O(V² log V + VE)",
            "worst": "O(V² log V + VE)"
          },
          "spaceComplexity": "O(V²)",
          "pseudocode": [
            "function Johnson(G):",
            "    // Step 1: Add a new vertex q with zero-weight edges to all vertices",
            "    G' = G with a new vertex q",
            "    for each vertex v in G",
            "        add edge from q to v with weight 0",
            "",
            "    // Step 2: Run Bellman-Ford from q to compute h values",
            "    if Bellman-Ford(G', q) returns negative cycle detected",
            "        return \"Graph contains a negative cycle\"",
            "    for each vertex v in G",
            "        h(v) = distance from q to v in G'",
            "",
            "    // Step 3: Reweight the edges using h values",
            "    for each edge (u,v) with weight w in G",
            "        w'(u,v) = w + h(u) - h(v)",
            "",
            "    // Step 4: Run Dijkstra from each vertex on reweighted graph",
            "    initialize distance matrix D[u][v] = infinity for all u,v",
            "    for each vertex u in G",
            "        run Dijkstra's algorithm from u on reweighted graph",
            "        for each vertex v in G",
            "            D[u][v] = distance from u to v in reweighted graph",
            "",
            "    // Step 5: Convert distances back to original graph",
            "    for each pair of vertices u,v in G",
            "        D[u][v] = D[u][v] - h(u) + h(v)",
            "",
            "    return D"
          ],
          "visualizationSteps": [
            "Add a new vertex q with zero-weight edges to all original vertices.",
            "Run Bellman-Ford algorithm from vertex q to detect negative cycles and compute h(v) values for each vertex.",
            "Reweight all edges in the graph using the formula: w'(u,v) = w(u,v) + h(u) - h(v).",
            "Verify that all edges now have non-negative weights.",
            "Run Dijkstra's algorithm from each vertex in the reweighted graph to find shortest paths.",
            "Convert the shortest paths in the reweighted graph back to the original graph using: dist(u,v) = dist'(u,v) - h(u) + h(v).",
            "The resulting distance matrix contains the shortest path distances between all pairs of vertices."
          ]
        },
        {
          "id": "astar",
          "name": "A* Search Algorithm",
          "description": "A best-first search algorithm that finds the shortest path from a start node to a goal node in a weighted graph, using a heuristic function to guide the search more efficiently than Dijkstra's algorithm.",
          "timeComplexity": {
            "best": "O(E)",
            "average": "O(E)",
            "worst": "O(b^d)"
          },
          "spaceComplexity": "O(V)",
          "pseudocode": [
            "function AStar(graph, start, goal):",
            "    // Initialize open and closed lists",
            "    openSet := {start}",
            "    closedSet := {}",
            "    ",
            "    // Initialize costs",
            "    g[start] := 0 // Cost from start to start",
            "    // Initialize estimated total cost from start to goal",
            "    f[start] := g[start] + heuristic(start, goal)",
            "    ",
            "    // Initialize tracking of best path",
            "    cameFrom := an empty map",
            "    ",
            "    while openSet is not empty:",
            "        // Current := the node in openSet with the lowest f-value",
            "        current := node in openSet with minimum f[node]",
            "        ",
            "        if current = goal:",
            "            return reconstructPath(cameFrom, current)",
            "        ",
            "        remove current from openSet",
            "        add current to closedSet",
            "        ",
            "        for each neighbor of current:",
            "            if neighbor in closedSet:",
            "                continue",
            "            ",
            "            // tentative_g is the distance from start to neighbor through current",
            "            tentative_g := g[current] + distance(current, neighbor)",
            "            ",
            "            if neighbor not in openSet or tentative_g < g[neighbor]:",
            "                cameFrom[neighbor] := current",
            "                g[neighbor] := tentative_g",
            "                f[neighbor] := g[neighbor] + heuristic(neighbor, goal)",
            "                ",
            "                if neighbor not in openSet:",
            "                    add neighbor to openSet",
            "    ",
            "    // Open set is empty but goal was never reached",
            "    return failure"
          ],
          "visualizationSteps": [
            "Initialize open set with the start node, and initialize g, f values.",
            "While the open set is not empty, select the node with lowest f-value.",
            "If the current node is the goal, reconstruct and return the path.",
            "Move current node from open set to closed set.",
            "For each neighbor of the current node, calculate tentative g-value.",
            "If the neighbor is in closed set, skip it.",
            "If the neighbor is not in open set or has a better g-value, update its g and f values.",
            "If the neighbor is not in open set, add it.",
            "Repeat until goal is found or open set is empty (failure)."
          ]
        },
        {
          "id": "ford-fulkerson",
          "name": "Ford-Fulkerson Algorithm",
          "description": "An algorithm for computing the maximum flow in a flow network, which repeatedly finds augmenting paths through the residual graph until no more can be found.",
          "timeComplexity": {
            "best": "O(E * max_flow)",
            "average": "O(E * max_flow)",
            "worst": "O(E * max_flow)"
          },
          "spaceComplexity": "O(V + E)",
          "pseudocode": [
            "function FordFulkerson(graph, source, sink):",
            "    // Initialize flow to 0 for all edges",
            "    for each edge (u,v) in graph:",
            "        flow[u,v] := 0",
            "        flow[v,u] := 0",
            "    ",
            "    // Residual graph initially equals the original graph",
            "    residualGraph := graph",
            "    maxFlow := 0",
            "    ",
            "    // While there is an augmenting path from source to sink",
            "    while path := findAugmentingPath(residualGraph, source, sink):",
            "        // Find the bottleneck capacity",
            "        bottleneck := min{ residualGraph[u,v] for each edge (u,v) in path }",
            "        ",
            "        // Update residual graph",
            "        for each edge (u,v) in path:",
            "            // Forward edge: decrease capacity",
            "            residualGraph[u,v] := residualGraph[u,v] - bottleneck",
            "            // Backward edge: increase capacity",
            "            residualGraph[v,u] := residualGraph[v,u] + bottleneck",
            "            ",
            "            // Update actual flow",
            "            if (u,v) is in original graph:",
            "                flow[u,v] := flow[u,v] + bottleneck",
            "            else:",
            "                flow[v,u] := flow[v,u] - bottleneck",
            "        ",
            "        maxFlow := maxFlow + bottleneck",
            "    ",
            "    return maxFlow"
          ],
          "visualizationSteps": [
            "Initialize flows to 0 for all edges in the network.",
            "Create a residual graph equal to the original graph.",
            "Find an augmenting path from source to sink in the residual graph (using BFS or DFS).",
            "Calculate the bottleneck capacity (minimum residual capacity along the path).",
            "Update the residual graph by decreasing forward edge capacities and increasing backward edge capacities by the bottleneck value.",
            "Update the flow on the original graph.",
            "Repeat steps 3-6 until no augmenting path exists.",
            "The maximum flow equals the sum of all bottleneck values."
          ]
        }
      ]
    },
    {
      "id": "dynamic-programming",
      "name": "Dynamic Programming",
      "description": "A method for solving complex problems by breaking them down into simpler subproblems and storing the results of overlapping subproblems.",
      "algorithms": [
        {
          "id": "fibonacci",
          "name": "Fibonacci Sequence",
          "description": "Computes Fibonacci numbers efficiently.",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure fibonacci(n: integer)",
            "    if n ≤ 1 then",
            "        return n",
            "    end if",
            "    create array fib[0...n]",
            "    fib[0] := 0",
            "    fib[1] := 1",
            "    for i := 2 to n do",
            "        fib[i] := fib[i-1] + fib[i-2]",
            "    end for",
            "    return fib[n]",
            "end procedure"
          ],
          "visualizationSteps": [
            "Initialize an array of size n+1.",
            "Set base cases: fib[0] = 0, fib[1] = 1.",
            "Iteratively calculate each Fibonacci number: fib[i] = fib[i-1] + fib[i-2].",
            "Return fib[n] as the result."
          ]
        },
        {
          "id": "matrix-chain-multiplication",
          "name": "Matrix Chain Multiplication",
          "description": "Determines the most efficient way to multiply a sequence of matrices.",
          "timeComplexity": {
            "best": "O(n³)",
            "average": "O(n³)",
            "worst": "O(n³)"
          },
          "spaceComplexity": "O(n²)",
          "pseudocode": [
            "procedure MatrixChainOrder(p: array of n+1 integers)",
            "    n := p.length - 1",
            "    create tables m[1..n][1..n] and s[1..n][1..n]",
            "    for i := 1 to n do",
            "        m[i][i] := 0",
            "    for l := 2 to n do",
            "        for i := 1 to n-l+1 do",
            "            j := i + l - 1",
            "            m[i][j] := ∞",
            "            for k := i to j-1 do",
            "                q := m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]",
            "                if q < m[i][j] then",
            "                    m[i][j] := q",
            "                    s[i][j] := k",
            "            end for",
            "        end for",
            "    end for",
            "    return m and s"
          ],
          "visualizationSteps": [
            "Initialize tables m[i][j] (for minimum operations) and s[i][j] (for optimal split points).",
            "Set the cost of multiplying a single matrix to 0 (diagonal cells in m).",
            "For chains of increasing length, compute the optimal split for each subproblem.",
            "For each subproblem (i,j), try all possible split points k between i and j.",
            "Calculate the cost for each split: cost = m[i][k] + m[k+1][j] + dimensions[i-1]*dimensions[k]*dimensions[j].",
            "Keep track of the minimum cost and the corresponding split point.",
            "Use the s table to reconstruct the optimal parenthesization of the matrices."
          ]
        },
        {
          "id": "edit-distance",
          "name": "Edit Distance",
          "description": "Calculates the minimum number of operations required to transform one string into another.",
          "timeComplexity": {
            "best": "O(m×n)",
            "average": "O(m×n)",
            "worst": "O(m×n)"
          },
          "spaceComplexity": "O(m×n)",
          "pseudocode": [
            "function editDistance(str1, str2):",
            "    m := length of str1",
            "    n := length of str2",
            "    create table dp[0...m][0...n]",
            "    ",
            "    // Base cases",
            "    for i := 0 to m do",
            "        dp[i][0] := i",
            "    end for",
            "    for j := 0 to n do",
            "        dp[0][j] := j",
            "    end for",
            "    ",
            "    // Fill the table",
            "    for i := 1 to m do",
            "        for j := 1 to n do",
            "            if str1[i-1] = str2[j-1] then",
            "                dp[i][j] := dp[i-1][j-1]",
            "            else",
            "                dp[i][j] := 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])",
            "            end if",
            "        end for",
            "    end for",
            "    ",
            "    return dp[m][n]"
          ],
          "visualizationSteps": [
            "Initialize a table dp[m+1][n+1] where dp[i][j] represents the edit distance between str1[0..i-1] and str2[0..j-1].",
            "Set base cases: dp[i][0] = i (deletions to get empty string) and dp[0][j] = j (insertions to get str2[0..j-1]).",
            "For each cell dp[i][j], compare characters str1[i-1] and str2[j-1].",
            "If characters match, dp[i][j] = dp[i-1][j-1] (no operation needed).",
            "If characters don't match, dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) (deletion, insertion, or substitution).",
            "The value in dp[m][n] represents the minimum edit distance."
          ]
        },
        {
          "id": "shortest-common-supersequence",
          "name": "Shortest Common Supersequence",
          "description": "Finds the shortest string that has both input strings as subsequences.",
          "timeComplexity": {
            "best": "O(m×n)",
            "average": "O(m×n)",
            "worst": "O(m×n)"
          },
          "spaceComplexity": "O(m×n)",
          "pseudocode": [
            "function shortestCommonSupersequence(str1, str2):",
            "    m := length of str1",
            "    n := length of str2",
            "    create table dp[0...m][0...n]",
            "",
            "    // Base cases",
            "    for i := 0 to m do",
            "        dp[i][0] := i",
            "    end for",
            "    for j := 0 to n do",
            "        dp[0][j] := j",
            "    end for",
            "",
            "    // Fill the table",
            "    for i := 1 to m do",
            "        for j := 1 to n do",
            "            if str1[i-1] = str2[j-1] then",
            "                dp[i][j] := 1 + dp[i-1][j-1]",
            "            else",
            "                dp[i][j] := 1 + min(dp[i-1][j], dp[i][j-1])",
            "            end if",
            "        end for",
            "    end for",
            "",
            "    // Reconstruct the SCS",
            "    i := m, j := n",
            "    scs := empty string",
            "    while i > 0 and j > 0 do",
            "        if str1[i-1] = str2[j-1] then",
            "            scs := str1[i-1] + scs",
            "            i := i - 1",
            "            j := j - 1",
            "        else if dp[i-1][j] < dp[i][j-1] then",
            "            scs := str1[i-1] + scs",
            "            i := i - 1",
            "        else",
            "            scs := str2[j-1] + scs",
            "            j := j - 1",
            "        end if",
            "    end while",
            "",
            "    // Add remaining characters",
            "    while i > 0 do",
            "        scs := str1[i-1] + scs",
            "        i := i - 1",
            "    end while",
            "    while j > 0 do",
            "        scs := str2[j-1] + scs",
            "        j := j - 1",
            "    end while",
            "",
            "    return scs"
          ],
          "visualizationSteps": [
            "Initialize a table dp[m+1][n+1] where dp[i][j] represents the length of the SCS of str1[0..i-1] and str2[0..j-1].",
            "Set base cases: dp[i][0] = i (include all characters from str1) and dp[0][j] = j (include all characters from str2).",
            "For each cell dp[i][j], compare characters str1[i-1] and str2[j-1].",
            "If characters match, dp[i][j] = 1 + dp[i-1][j-1] (add the character once).",
            "If characters don't match, dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1]) (add character from str1 or str2).",
            "Reconstruct the SCS by tracing back from dp[m][n] and adding characters to the result string.",
            "When characters match, add the character once and move diagonally.",
            "When characters don't match, choose the direction of the minimum value and add the corresponding character."
          ]
        },
        {
          "id": "coin-change",
          "name": "Coin Change Problem",
          "description": "Counts the number of ways to make change for a given amount using a set of coin denominations.",
          "timeComplexity": {
            "best": "O(n×m)",
            "average": "O(n×m)",
            "worst": "O(n×m)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure CoinChange(coins, amount)",
            "    // Initialize DP table",
            "    create array dp[0...amount] filled with 0",
            "    dp[0] := 1  // Base case: one way to make change for 0",
            "    ",
            "    // For each coin",
            "    for i := 0 to coins.length - 1 do",
            "        coin := coins[i]",
            "        // For each amount from coin to target",
            "        for j := coin to amount do",
            "            dp[j] += dp[j - coin]",
            "    ",
            "    return dp[amount]"
          ],
          "visualizationSteps": [
            "Initialize a DP array of size (amount+1), with all values set to 0.",
            "Set the base case: dp[0] = 1 (there is one way to make change for amount 0).",
            "For each coin denomination, iterate through all amounts from the coin value to the target amount.",
            "For each amount, add the number of ways to make change for (amount - coin value) to the current ways.",
            "The formula is: dp[amount] += dp[amount - coin].",
            "Continue this process for all coins and all applicable amounts.",
            "The final value in dp[amount] represents the total number of ways to make change."
          ]
        },
        {
          "id": "subset-sum",
          "name": "Subset Sum Problem",
          "description": "Determines if there is a subset with a sum equal to a given target.",
          "timeComplexity": {
            "best": "O(n×sum)",
            "average": "O(n×sum)",
            "worst": "O(n×sum)"
          },
          "spaceComplexity": "O(n×sum)",
          "pseudocode": [
            "procedure subsetSum(array[], targetSum)",
            "    n = array.length",
            "    dp[0...n][0...targetSum] = false",
            "    dp[0][0] = true  // Base case: empty subset can make sum 0",
            "",
            "    for i = 1 to n do",
            "        for j = 0 to targetSum do",
            "            // If we can get sum j without the current element",
            "            dp[i][j] = dp[i-1][j]",
            "",
            "            // If current element can contribute to sum j",
            "            if j >= array[i-1] and dp[i-1][j-array[i-1]] then",
            "                dp[i][j] = true",
            "            end if",
            "        end for",
            "    end for",
            "",
            "    return dp[n][targetSum]",
            "end procedure"
          ],
          "visualizationSteps": [
            "Create a 2D DP table where dp[i][j] represents if there's a subset of the first i elements that sums to j.",
            "Initialize with dp[0][0] = true (empty subset can make sum 0) and all other dp[0][j] = false.",
            "For each element, consider two choices: include it or exclude it.",
            "If excluding: dp[i][j] = dp[i-1][j]",
            "If including: check if j ≥ current element and dp[i-1][j-current element] is true",
            "If either choice leads to true, set dp[i][j] = true.",
            "The final value dp[n][targetSum] indicates whether a solution exists."
          ]
        },
        {
          "id": "rod-cutting",
          "name": "Rod Cutting Problem",
          "description": "Maximizes revenue by cutting a rod into pieces of different lengths with different prices.",
          "timeComplexity": {
            "best": "O(n²)",
            "average": "O(n²)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure rodCutting(prices[], rodLength)",
            "    // Create an array to store maximum revenue for each length",
            "    dp[0...rodLength] = 0",
            "    cuts[0...rodLength] = 0  // To store optimal cuts",
            "",
            "    // Fill DP table bottom-up",
            "    for i = 1 to rodLength do",
            "        maxRevenue = -∞",
            "        for j = 1 to i do",
            "            // revenue = price of piece of length j + revenue from remaining rod",
            "            currentRevenue = prices[j] + dp[i-j]",
            "            if currentRevenue > maxRevenue then",
            "                maxRevenue = currentRevenue",
            "                cuts[i] = j",
            "            end if",
            "        end for",
            "        dp[i] = maxRevenue",
            "    end for",
            "",
            "    return dp[rodLength], cuts  // Maximum revenue and optimal cuts",
            "end procedure"
          ],
          "visualizationSteps": [
            "Create a DP array where dp[i] represents the maximum revenue for a rod of length i.",
            "Initialize with dp[0] = 0 (no revenue from a rod of length 0).",
            "For each rod length i from 1 to n, try all possible cuts j (from 1 to i).",
            "For each cut j, calculate revenue as prices[j] + dp[i-j].",
            "Update dp[i] with the maximum revenue found, and store the corresponding cut length.",
            "The final value dp[n] contains the maximum possible revenue.",
            "Trace back through the cuts array to find the optimal cutting strategy."
          ]
        },
        {
          "id": "knapsack",
          "name": "Knapsack Problem",
          "description": "Selects items with maximum total value while respecting a weight constraint.",
          "timeComplexity": {
            "best": "O(nW)",
            "average": "O(nW)",
            "worst": "O(nW)"
          },
          "spaceComplexity": "O(nW)",
          "pseudocode": [
            "procedure knapsack(values: array of integers, weights: array of integers, W: integer)",
            "    n := length(values)",
            "    create table dp[0...n][0...W] initialized to 0",
            "    for i := 1 to n do",
            "        for w := 0 to W do",
            "            if weights[i-1] ≤ w then",
            "                dp[i][w] := max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])",
            "            else",
            "                dp[i][w] := dp[i-1][w]",
            "            end if",
            "        end for",
            "    end for",
            "    return dp[n][W]",
            "end procedure"
          ],
          "visualizationSteps": [
            "Create a table to store maximum value for each subproblem",
            "For each item and weight combination",
            "Decide whether to include the current item",
            "If including it gives more value, update the table",
            "Final cell contains the maximum possible value"
          ]
        },
        {
          "id": "lcs",
          "name": "Longest Common Subsequence",
          "description": "Finds the longest subsequence that appears in the same relative order in two sequences but not necessarily contiguous.",
          "timeComplexity": {
            "best": "O(m*n)",
            "average": "O(m*n)",
            "worst": "O(m*n)"
          },
          "spaceComplexity": "O(m*n)",
          "pseudocode": [
            "procedure LCS(X: sequence of length m, Y: sequence of length n)",
            "    create table dp[0...m][0...n] initialized to 0",
            "    for i := 1 to m do",
            "        for j := 1 to n do",
            "            if X[i-1] = Y[j-1] then",
            "                dp[i][j] := dp[i-1][j-1] + 1",
            "            else",
            "                dp[i][j] := max(dp[i-1][j], dp[i][j-1])",
            "            end if",
            "        end for",
            "    end for",
            "    // To find the actual LCS, backtrack through the table",
            "    return dp[m][n]",
            "end procedure"
          ],
          "visualizationSteps": [
            "Initialize a 2D table with rows and columns for each sequence",
            "Compare characters from both sequences",
            "If characters match, increment the value from the diagonal cell",
            "If characters don't match, take the maximum value from the left or above",
            "The bottom-right cell contains the length of the LCS",
            "Backtrack through the table to find the actual subsequence"
          ]
        },
        {
          "id": "lis",
          "name": "Longest Increasing Subsequence",
          "description": "Finds a subsequence of a given sequence in which the elements are in strictly increasing order and the subsequence is as long as possible.",
          "timeComplexity": {
            "best": "O(n²)",
            "average": "O(n²)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure LIS(A: array of length n)",
            "    initialize dp[0...n-1] to 1",
            "    for i := 0 to n-1 do",
            "        for j := 0 to i-1 do",
            "            if A[j] < A[i] and dp[j] + 1 > dp[i] then",
            "                dp[i] := dp[j] + 1",
            "                prev[i] := j  // To reconstruct the LIS",
            "            end if",
            "        end for",
            "    end for",
            "    // Find the maximum length and its index",
            "    maxLength := max(dp)",
            "    maxIndex := index of maxLength in dp",
            "    // Reconstruct the LIS using prev array",
            "    return the reconstructed LIS",
            "end procedure"
          ],
          "visualizationSteps": [
            "Initialize an array dp where dp[i] represents the length of the LIS ending at index i",
            "Initially set all dp values to 1 (as single elements are valid increasing subsequences)",
            "For each position, compare with all previous elements",
            "If a previous element is smaller, we can extend its subsequence",
            "Update dp[i] to the maximum possible length",
            "Backtrack to construct the actual LIS"
          ]
        }
      ]
    },
    {
      "id": "divide-and-conquer",
      "name": "Divide and Conquer Algorithms",
      "description": "Algorithms that break down problems into subproblems of the same type, solve them, and combine their solutions.",
      "algorithms": [
        {
          "id": "strassen-matrix-multiplication",
          "name": "Strassen's Matrix Multiplication",
          "description": "A recursive algorithm that reduces the number of recursive calls required for matrix multiplication, improving efficiency from O(n³) to approximately O(n^2.81).",
          "timeComplexity": {
            "best": "O(n^2.81)",
            "average": "O(n^2.81)",
            "worst": "O(n^2.81)"
          },
          "spaceComplexity": "O(n²)",
          "pseudocode": [
            "procedure StrassenMatrixMultiply(A, B):",
            "    n := size of A and B",
            "    if n = 1 then",
            "        return A[0,0] * B[0,0]",
            "    end if",
            "",
            "    // Divide matrices into 4 quadrants each",
            "    a11, a12, a21, a22 := divide A into quadrants",
            "    b11, b12, b21, b22 := divide B into quadrants",
            "",
            "    // Calculate 7 products using recursive calls",
            "    p1 := StrassenMatrixMultiply(a11 + a22, b11 + b22)",
            "    p2 := StrassenMatrixMultiply(a21 + a22, b11)",
            "    p3 := StrassenMatrixMultiply(a11, b12 - b22)",
            "    p4 := StrassenMatrixMultiply(a22, b21 - b11)",
            "    p5 := StrassenMatrixMultiply(a11 + a12, b22)",
            "    p6 := StrassenMatrixMultiply(a21 - a11, b11 + b12)",
            "    p7 := StrassenMatrixMultiply(a12 - a22, b21 + b22)",
            "",
            "    // Calculate result quadrants",
            "    c11 := p1 + p4 - p5 + p7",
            "    c12 := p3 + p5",
            "    c21 := p2 + p4",
            "    c22 := p1 - p2 + p3 + p6",
            "",
            "    // Combine the four quadrants into a single result matrix",
            "    return combine(c11, c12, c21, c22)",
            "end procedure"
          ],
          "visualizationSteps": [
            "Check if matrices are of compatible size for multiplication",
            "If matrices are 1x1, return simple product",
            "Divide each matrix into four quadrants",
            "Calculate seven products with recursive calls",
            "Calculate result quadrants using the seven products",
            "Combine the quadrants to form the final matrix"
          ]
        },
        {
            "id": "karatsuba",
            "name": "Karatsuba Multiplication",
            "description": "A divide-and-conquer algorithm for fast multiplication of large integers that reduces the number of multiplications needed compared to the traditional method.",
            "timeComplexity": {
              "best": "O(n^log₂3)",
              "average": "O(n^log₂3)",
              "worst": "O(n^log₂3)"
            },
            "spaceComplexity": "O(n)",
            "pseudocode": [
              "procedure Karatsuba(x, y):",
              "    // Base case",
              "    if x < 10 or y < 10 then",
              "        return x * y",
              "    end if",
              "",
              "    // Calculate the size of the numbers",
              "    n := max(size of x, size of y)",
              "    m := ⌊n/2⌋",
              "",
              "    // Split the digits",
              "    a := ⌊x / 10^m⌋",
              "    b := x mod 10^m",
              "    c := ⌊y / 10^m⌋",
              "    d := y mod 10^m",
              "",
              "    // Three recursive calls",
              "    ac := Karatsuba(a, c)",
              "    bd := Karatsuba(b, d)",
              "    abcd := Karatsuba(a + b, c + d) - ac - bd",
              "",
              "    // Combine results",
              "    return ac * 10^(2*m) + abcd * 10^m + bd",
              "end procedure"
            ],
            "visualizationSteps": [
              "Split each large number into two parts",
              "Calculate three recursive products instead of four",
              "Use the formula: xy = (10^n)*ac + (10^(n/2))*(ad+bc) + bd",
              "Calculate (a+b)(c+d) and subtract ac and bd to get (ad+bc)",
              "Combine the results to get the final product",
              "Base case handles small numbers directly"
            ]
        },
        {
            "id": "binary-search-2",
            "name": "Binary Search",
            "description": "An efficient search algorithm that works on sorted arrays by repeatedly dividing the search interval in half.",
            "timeComplexity": {
              "best": "O(1)",
              "average": "O(log n)",
              "worst": "O(log n)"
            },
            "spaceComplexity": "O(1)",
            "pseudocode": [
              "procedure binarySearch(A, target)",
              "    left := 0",
              "    right := length(A) - 1",
              "    while left ≤ right do",
              "        mid := (left + right) / 2",
              "        if A[mid] = target then",
              "            return mid",
              "        end if",
              "        if A[mid] < target then",
              "            left := mid + 1",
              "        else",
              "            right := mid - 1",
              "        end if",
              "    end while",
              "    return -1",
              "end procedure"
            ],
            "visualizationSteps": [
              "Start with left pointer at the beginning and right pointer at the end of the sorted array",
              "Find the middle element between the left and right pointers",
              "If the middle element equals the target, return its position",
              "If the middle element is less than the target, move the left pointer to mid+1",
              "If the middle element is greater than the target, move the right pointer to mid-1",
              "Repeat until the element is found or the search space is empty"
            ]
        },
        {
            "id": "merge-sort-2",
            "name": "Merge Sort",
            "description": "Divides the array into halves, sorts them recursively, and then merges the sorted halves.",
            "timeComplexity": {
              "best": "O(n log n)",
              "average": "O(n log n)",
              "worst": "O(n log n)"
            },
            "spaceComplexity": "O(n)",
            "pseudocode": [
              "procedure mergeSort(A: list of sortable items)",
              "    if length(A) ≤ 1 then",
              "        return A",
              "    end if",
              "    mid := length(A)/2",
              "    left := mergeSort(A[0...mid-1])",
              "    right := mergeSort(A[mid...length(A)-1])",
              "    return merge(left, right)",
              "end procedure",
              "",
              "procedure merge(left, right: list of sortable items)",
              "    result := []",
              "    while left.length > 0 and right.length > 0 do",
              "        if left[0] ≤ right[0] then",
              "            append left[0] to result",
              "            left := left[1...left.length-1]",
              "        else",
              "            append right[0] to result",
              "            right := right[1...right.length-1]",
              "        end if",
              "    end while",
              "    append remaining elements of left to result",
              "    append remaining elements of right to result",
              "    return result",
              "end procedure"
            ],
            "visualizationSteps": [
              "Divide array into two halves",
              "Recursively sort both halves",
              "Merge sorted halves",
              "Compare elements and place in correct order",
              "Continue until entire array is sorted"
            ]
        },
        {
            "id": "closest-pair",
            "name": "Closest Pair of Points",
            "description": "Finds the pair of points with the smallest distance between them in a set of points in a 2D plane.",
            "timeComplexity": {
              "best": "O(n log n)",
              "average": "O(n log n)",
              "worst": "O(n log n)"
            },
            "spaceComplexity": "O(n)",
            "pseudocode": [
              "procedure ClosestPair(P: list of points)",
              "    // Sort points by x-coordinate",
              "    sort P by x-coordinate",
              "    return ClosestPairRecursive(P)",
              "end procedure",
              "",
              "procedure ClosestPairRecursive(P: list of points)",
              "    n := length(P)",
              "    // Base case: brute force when n is small",
              "    if n ≤ 3 then",
              "        return BruteForceClosestPair(P)",
              "    end if",
              "    ",
              "    // Divide points into left and right halves",
              "    mid := n / 2",
              "    midPoint := P[mid]",
              "    leftHalf := P[0...mid-1]",
              "    rightHalf := P[mid...n-1]",
              "    ",
              "    // Recursively find closest pairs in each half",
              "    leftPair := ClosestPairRecursive(leftHalf)",
              "    rightPair := ClosestPairRecursive(rightHalf)",
              "    ",
              "    // Find minimum distance from left and right halves",
              "    delta := min(distance(leftPair), distance(rightPair))",
              "    ",
              "    // Find points in strip around dividing line",
              "    strip := [p in P where |p.x - midPoint.x| < delta]",
              "    sort strip by y-coordinate",
              "    ",
              "    // Check for closer pairs across dividing line",
              "    for i := 0 to length(strip) - 1 do",
              "        // Only need to check 7 points ahead (proved mathematically)",
              "        for j := i + 1 to min(i + 7, length(strip) - 1) do",
              "            if strip[j].y - strip[i].y < delta then",
              "                dist := distance(strip[i], strip[j])",
              "                if dist < delta then",
              "                    delta := dist",
              "                    closestPair := (strip[i], strip[j])",
              "                end if",
              "            end if",
              "        end for",
              "    end for",
              "    ",
              "    return closestPair with distance delta",
              "end procedure"
            ],
            "visualizationSteps": [
              "Sort all points by x-coordinate",
              "Divide the points into two halves by a vertical line",
              "Recursively find closest pairs in each half",
              "Find closest pair across the dividing line using a strip",
              "Compare all points in the strip to find potential closer pairs",
              "Return the overall closest pair of points"
            ]
        },
        {
            "id": "quick-sort-2",
            "name": "Quick Sort",
            "description": "Selects a 'pivot' element and partitions the array around it, recursively sorting the sub-arrays.",
            "timeComplexity": {
              "best": "O(n log n)",
              "average": "O(n log n)",
              "worst": "O(n²)"
            },
            "spaceComplexity": "O(log n)",
            "pseudocode": [
              "procedure quickSort(A: list of sortable items, low, high: indices)",
              "    if low < high then",
              "        pivot := partition(A, low, high)",
              "        quickSort(A, low, pivot - 1)",
              "        quickSort(A, pivot + 1, high)",
              "    end if",
              "end procedure",
              "",
              "procedure partition(A: list of sortable items, low, high: indices)",
              "    pivot := A[high]",
              "    i := low - 1",
              "    for j := low to high - 1 do",
              "        if A[j] ≤ pivot then",
              "            i := i + 1",
              "            swap(A[i], A[j])",
              "        end if",
              "    end for",
              "    swap(A[i + 1], A[high])",
              "    return i + 1",
              "end procedure"
            ],
            "visualizationSteps": [
              "Select a pivot element",
              "Partition array around pivot",
              "Place elements smaller than pivot before it",
              "Place elements greater than pivot after it",
              "Recursively sort both partitions"
            ]
        },
        {
            "id": "fft",
            "name": "Fast Fourier Transform",
            "description": "An algorithm that efficiently computes the Discrete Fourier Transform (DFT) of a sequence, converting a signal from the time domain to the frequency domain.",
            "timeComplexity": {
              "best": "O(n log n)",
              "average": "O(n log n)",
              "worst": "O(n log n)"
            },
            "spaceComplexity": "O(n)",
            "pseudocode": [
              "procedure FFT(x: complex array of size n = 2^k)",
              "    // Base case",
              "    if n = 1 then",
              "        return x",
              "    end if",
              "",
              "    // Divide sequence into even and odd indices",
              "    even := [x[0], x[2], ..., x[n-2]]",
              "    odd := [x[1], x[3], ..., x[n-1]]",
              "",
              "    // Recursively compute FFT on even and odd parts",
              "    even_fft := FFT(even)",
              "    odd_fft := FFT(odd)",
              "",
              "    // Combine results using complex roots of unity",
              "    result := new complex array of size n",
              "    for k := 0 to n/2 - 1 do",
              "        // ω_n^k is the complex root of unity",
              "        ω := e^(-2πi·k/n)",
              "",
              "        // Butterfly operation",
              "        result[k] := even_fft[k] + ω * odd_fft[k]",
              "        result[k + n/2] := even_fft[k] - ω * odd_fft[k]",
              "    end for",
              "",
              "    return result",
              "end procedure",
              "",
              "// Iterative implementation",
              "procedure iterativeFFT(x: complex array of size n = 2^k)",
              "    // Bit-reversal permutation",
              "    x := bitReversalPermutation(x)",
              "",
              "    // Main FFT calculation",
              "    for s := 1 to log₂(n) do",
              "        m := 2^s",
              "        ω_m := e^(-2πi/m)",
              "",
              "        for k := 0 to n-1 by m do",
              "            ω := 1",
              "            for j := 0 to m/2 - 1 do",
              "                t := ω * x[k + j + m/2]",
              "                u := x[k + j]",
              "                x[k + j] := u + t",
              "                x[k + j + m/2] := u - t",
              "                ω := ω * ω_m",
              "            end for",
              "        end for",
              "    end for",
              "",
              "    return x",
              "end procedure"
            ],
            "visualizationSteps": [
              "Perform bit-reversal permutation of input array",
              "Apply butterfly operations stage-by-stage",
              "For each stage, use twiddle factors (complex roots of unity)",
              "Combine smaller DFTs into larger ones in log n stages",
              "Produce frequency-domain representation of the input signal",
              "Each frequency bin represents amplitude and phase at that frequency"
            ]
        }
      ]
    },
    {
      "id": "string",
      "name": "String Algorithms",
      "description": "Algorithms specifically designed for string processing and manipulation.",
      "algorithms": [
        {
          "id": "naive-pattern-searching",
          "name": "Naive Pattern Searching",
          "description": "A simple algorithm that checks every position in the text where the pattern may match by comparing characters one by one.",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O((n-m+1)×m)",
            "worst": "O(n×m)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<p>Naive Pattern Searching is the most straightforward approach to string matching, checking all possible positions in the text where the pattern might occur:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Simplicity:</span> Straightforward implementation requiring minimal code.</li>",
            "  <li><span class=\"font-medium\">No Preprocessing:</span> Doesn't require any preprocessing of the pattern or text.</li>",
            "  <li><span class=\"font-medium\">Complete Scan:</span> Examines every possible position where the pattern could match.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Slide the pattern over the text one position at a time</li>",
            "    <li>For each position, compare all characters of the pattern with the corresponding characters in the text</li>",
            "    <li>If all characters match, record the starting position as a match</li>",
            "    <li>If any character doesn't match, immediately move to the next position</li>",
            "    <li>Continue until the pattern reaches the end of the text</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<p>The naive approach is simple but can be inefficient for large texts or patterns:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n) - when the first character of the pattern is not present in the text</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O((n-m+1)×m) - for each of the n-m+1 positions, potentially comparing all m characters</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n×m) - when characters match but the last character repeatedly fails</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(1) - requires only constant extra space</li>",
            "</ul>",
            "<p>Despite its inefficiency for large inputs, the naive approach is useful for:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Small texts and patterns</li>",
            "  <li>Educational purposes to understand string matching basics</li>",
            "  <li>Situations where the overhead of preprocessing would outweigh the benefits</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure naivePatternSearch(text: string, pattern: string)",
            "    n := length(text)",
            "    m := length(pattern)",
            "    matches := empty array",
            "",
            "    // Slide the pattern over the text one by one",
            "    for i := 0 to n-m do",
            "        j := 0",
            "        // Check for pattern match at current position",
            "        while j < m and text[i+j] = pattern[j] do",
            "            j := j + 1",
            "        end while",
            "",
            "        // If pattern was fully matched",
            "        if j = m then",
            "            add i to matches // Pattern found at index i",
            "        end if",
            "    end for",
            "",
            "    return matches",
            "end procedure"
          ],
          "visualizationSteps": [
            "Align pattern with the beginning of the text",
            "Compare characters of pattern with text one by one",
            "If all characters match, record position as a match",
            "If any character mismatch occurs, shift pattern one position to the right",
            "Repeat until the pattern reaches the end of the text"
          ]
        },
        {
          "id": "kmp",
          "name": "KMP Algorithm",
          "description": "Efficiently finds occurrences of a pattern in a text without backtracking.",
          "timeComplexity": {
            "best": "O(n+m)",
            "average": "O(n+m)",
            "worst": "O(n+m)"
          },
          "spaceComplexity": "O(m)",
          "howItWorks": [
            "<p>The Knuth-Morris-Pratt (KMP) algorithm is an efficient string searching algorithm that uses information about the pattern itself to minimize redundant comparisons:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">No Backtracking:</span> The KMP algorithm never goes back in the text, always moving forward.</li>",
            "  <li><span class=\"font-medium\">Preprocessing:</span> Computes a partial match table (LPS - Longest Prefix Suffix) to know how far to shift the pattern when a mismatch occurs.</li>",
            "  <li><span class=\"font-medium\">Linear Time:</span> Achieves O(n+m) time complexity in all cases.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<p>The KMP algorithm has two main phases:</p>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">1. Preprocessing Phase</h4>",
            "<div class=\"pl-4\">",
            "  <p>Compute the LPS (Longest Prefix Suffix) array:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>LPS[i] contains the length of the longest proper prefix of pattern[0...i] which is also a suffix</li>",
            "    <li>This is computed using a two-pointer technique in O(m) time</li>",
            "    <li>The LPS array helps determine where to resume matching after a mismatch</li>",
            "  </ul>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">2. Searching Phase</h4>",
            "<div class=\"pl-4\">",
            "  <p>Use the LPS array to efficiently find all occurrences of the pattern in the text:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>When a match occurs, increment both pattern and text pointers</li>",
            "    <li>When a mismatch occurs, use the LPS value to determine where to resume matching in the pattern</li>",
            "    <li>No backtracking in the text is needed - the text pointer always moves forward</li>",
            "  </ul>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<p>KMP is particularly effective when the pattern has repeating subpatterns:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span> O(n+m) in all cases (O(m) for preprocessing, O(n) for searching)</li>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(m) for storing the LPS array</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure KMP_Search(text: string, pattern: string)",
            "    n := length(text)",
            "    m := length(pattern)",
            "    if m = 0 then",
            "        return 0",
            "    end if",
            "    lps := computeLPSArray(pattern, m)",
            "    i := 0 // for text",
            "    j := 0 // for pattern",
            "    while i < n do",
            "        if pattern[j] = text[i] then",
            "            i++",
            "            j++",
            "        end if",
            "        if j = m then",
            "            report match at index i-j",
            "            j := lps[j-1]",
            "        else if i < n and pattern[j] ≠ text[i] then",
            "            if j ≠ 0 then",
            "                j := lps[j-1]",
            "            else",
            "                i++",
            "            end if",
            "        end if",
            "    end while",
            "end procedure",
            "",
            "procedure computeLPSArray(pattern: string, m: integer)",
            "    lps := new array of size m",
            "    lps[0] := 0",
            "    len := 0",
            "    i := 1",
            "    while i < m do",
            "        if pattern[i] = pattern[len] then",
            "            len++",
            "            lps[i] := len",
            "            i++",
            "        else",
            "            if len ≠ 0 then",
            "                len := lps[len-1]",
            "            else",
            "                lps[i] := 0",
            "                i++",
            "            end if",
            "        end if",
            "    end while",
            "    return lps",
            "end procedure"
          ],
          "visualizationSteps": [
            "Compute the Longest Prefix Suffix (LPS) array",
            "Use LPS array to avoid redundant comparisons",
            "Compare text and pattern characters",
            "If mismatch occurs, use LPS to determine next position",
            "Continue until end of text is reached"
          ]
        },
        {
          "id": "rabin-karp",
          "name": "Rabin-Karp Algorithm",
          "description": "A string searching algorithm that uses hashing to find pattern matches within a text.",
          "timeComplexity": {
            "best": "O(n+m)",
            "average": "O(n+m)",
            "worst": "O(nm)"
          },
          "spaceComplexity": "O(1)",
          "howItWorks": [
            "<p>The Rabin-Karp algorithm is a string searching algorithm that uses hashing to find pattern matches in text:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Hashing:</span> Uses a rolling hash function to efficiently compare pattern with text windows.</li>",
            "  <li><span class=\"font-medium\">Filtering:</span> Quickly eliminates most non-matching positions through hash comparisons.</li>",
            "  <li><span class=\"font-medium\">Multi-pattern Capability:</span> Can be extended to search for multiple patterns simultaneously.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">1. Hash Calculation</h4>",
            "<div class=\"pl-4\">",
            "  <p>Calculate hash values for the pattern and each text window of length m:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>Compute the hash value for the pattern</li>",
            "    <li>Compute the hash value for the first m characters of the text</li>",
            "    <li>For subsequent windows, use a rolling hash function for O(1) calculation</li>",
            "  </ul>",
            "  <p class=\"italic text-sm\">The rolling hash function is key to the algorithm's efficiency - it allows computing the next window's hash using the previous hash in constant time.</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">2. Hash Comparison and Verification</h4>",
            "<div class=\"pl-4\">",
            "  <p>For each window position in the text:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>Compare the hash values of the pattern and current text window</li>",
            "    <li>If hashes match, verify character by character (to handle hash collisions)</li>",
            "    <li>If a complete match is found, record the position</li>",
            "    <li>Slide the window by one position and calculate the next hash</li>",
            "  </ul>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<p>The Rabin-Karp algorithm's performance depends on the hash function and pattern distribution:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Average case:</span> O(n+m) - when hash collisions are rare</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n×m) - when many hash collisions occur requiring character checks</li>",
            "  <li><span class=\"font-medium\">Space complexity:</span> O(1) - requires only constant extra space</li>",
            "</ul>",
            "<p>Rabin-Karp excels in multi-pattern matching scenarios, where it can find multiple patterns in a single pass through the text.</p>"
          ],
          "pseudocode": [
            "procedure RabinKarp(text: string, pattern: string, q: prime number)",
            "    n := length(text)",
            "    m := length(pattern)",
            "    d := 256 // Number of characters in input alphabet",
            "    h := 1",
            "    p := 0 // Hash value for pattern",
            "    t := 0 // Hash value for text",
            "    matches := empty array",
            "",
            "    // Calculate h = d^(m-1) % q",
            "    for i := 1 to m-1 do",
            "        h := (h * d) % q",
            "    end for",
            "",
            "    // Calculate initial hash values for pattern and first text window",
            "    for i := 0 to m-1 do",
            "        p := (d * p + pattern[i]) % q",
            "        t := (d * t + text[i]) % q",
            "    end for",
            "",
            "    // Slide pattern over text one by one",
            "    for i := 0 to n-m do",
            "        // Check if hash values match",
            "        if p = t then",
            "            // Check for actual character match",
            "            j := 0",
            "            while j < m and text[i+j] = pattern[j] do",
            "                j := j + 1",
            "            end while",
            "",
            "            // If pattern fully matched",
            "            if j = m then",
            "                add i to matches // Pattern found at index i",
            "            end if",
            "        end if",
            "",
            "        // Calculate hash value for next window",
            "        if i < n-m then",
            "            t := (d * (t - text[i] * h) + text[i+m]) % q",
            "            // Handle negative value of t",
            "            if t < 0 then",
            "                t := t + q",
            "            end if",
            "        end if",
            "    end for",
            "",
            "    return matches",
            "end procedure"
          ],
          "visualizationSteps": [
            "Calculate hash values for the pattern and the first window of text",
            "For each position in the text:",
            "Compare hash values of pattern and current text window",
            "If hashes match, verify character by character",
            "Use a rolling hash function to efficiently calculate the next window's hash",
            "Continue until the end of text is reached"
          ]
        },
        {
          "id": "z-algorithm",
          "name": "Z Algorithm",
          "description": "A linear time string matching algorithm that utilizes a Z array to efficiently find all occurrences of a pattern in a text.",
          "timeComplexity": {
            "best": "O(n+m)",
            "average": "O(n+m)",
            "worst": "O(n+m)"
          },
          "spaceComplexity": "O(n+m)",
          "howItWorks": [
            "<p>The Z Algorithm is a linear time string matching algorithm that creates a Z array to efficiently find all occurrences of a pattern in a text:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Z Array:</span> The Z array Z[i] represents the length of the longest substring starting at position i that matches the prefix of the string.</li>",
            "  <li><span class=\"font-medium\">Linear Time:</span> Utilizes techniques to compute the Z array in linear time.</li>",
            "  <li><span class=\"font-medium\">Prefix Matching:</span> Identifies matches by finding positions where Z value equals the pattern length.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">1. Concatenation</h4>",
            "<div class=\"pl-4\">",
            "  <p>Create a new string by concatenating:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>The pattern</li>",
            "    <li>A special character (usually '$' or '#') that doesn't appear in the text or pattern</li>",
            "    <li>The text</li>",
            "  </ul>",
            "  <p>This creates a single string like: \"pattern$text\"</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">2. Z Array Computation</h4>",
            "<div class=\"pl-4\">",
            "  <p>Compute the Z array for the concatenated string:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>Z[i] is the length of the longest substring starting at position i that matches the prefix</li>",
            "    <li>Uses a technique with \"Z boxes\" to avoid redundant comparisons</li>",
            "    <li>Maintains a window [L,R] where R is the rightmost position so far such that [L,R] is a Z-box</li>",
            "  </ul>",
            "  <p class=\"italic text-sm\">The Z-box technique allows most values to be computed without character-by-character comparison, by reusing previous calculations.</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">3. Pattern Matching</h4>",
            "<div class=\"pl-4\">",
            "  <p>Use the Z array to find pattern matches:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>For any position i after the special character, if Z[i] = pattern.length, then a pattern match occurs at position i - pattern.length - 1 in the original text</li>",
            "  </ul>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<p>The Z Algorithm is efficient for string matching:</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span> O(n+m) in all cases</li>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(n+m) for storing the concatenated string and Z array</li>",
            "</ul>",
            "<p>It's especially useful for applications requiring multiple pattern searches or where the pattern and text need preprocessing for other operations.</p>"
          ],
          "pseudocode": [
            "procedure ZAlgorithm(pattern, text)",
            "    // Create concatenated string",
            "    s := pattern + '$' + text",
            "    n := length(s)",
            "    m := length(pattern)",
            "    Z := new array of size n",
            "    matches := empty array",
            "",
            "    // Construct Z Array",
            "    l := 0, r := 0 // Z box boundaries",
            "    for i := 1 to n-1 do",
            "        if i > r then",
            "            // Outside Z box, compute naively",
            "            l := i",
            "            r := i",
            "            while r < n and s[r-l] = s[r] do",
            "                r := r + 1",
            "            end while",
            "            Z[i] := r - l",
            "            r := r - 1",
            "        else",
            "            // Inside Z box, use previously computed values",
            "            k := i - l",
            "            if Z[k] < r - i + 1 then",
            "                Z[i] := Z[k]",
            "            else",
            "                // Need to extend Z box",
            "                l := i",
            "                while r < n and s[r-l] = s[r] do",
            "                    r := r + 1",
            "                end while",
            "                Z[i] := r - l",
            "                r := r - 1",
            "            end if",
            "        end if",
            "    end for",
            "",
            "    // Find pattern matches",
            "    for i := m + 1 to n - 1 do",
            "        if Z[i] = m then",
            "            matches.add(i - m - 1) // Pattern found at this position in text",
            "        end if",
            "    end for",
            "",
            "    return matches",
            "end procedure"
          ],
          "visualizationSteps": [
            "Concatenate pattern + special character + text",
            "Calculate Z array where Z[i] represents the length of the longest substring starting at position i that is also a prefix of the string",
            "Use Z box technique to efficiently compute Z values",
            "Identify matches where Z value equals pattern length",
            "Return positions of all complete matches"
          ]
        },
        {
          "id": "boyer-moore",
          "name": "Boyer-Moore Algorithm",
          "description": "An efficient string searching algorithm that uses two preprocessed rules (bad character and good suffix) to skip unnecessary comparisons, making it very efficient for long patterns.",
          "timeComplexity": {
            "best": "O(n/m)",
            "average": "O(n)",
            "worst": "O(n×m)"
          },
          "spaceComplexity": "O(k+m) where k is the alphabet size",
          "howItWorks": [
            "<p>The Boyer-Moore algorithm is an efficient string searching algorithm that uses two powerful heuristics to skip portions of the text, making it faster than many other string matching algorithms:</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Right-to-Left Scanning:</span> Unlike most string algorithms that scan from left to right, Boyer-Moore compares characters from right to left within the pattern.</li>",
            "  <li><span class=\"font-medium\">Skip Techniques:</span> The algorithm uses two rules to determine how many characters to skip when a mismatch occurs.</li>",
            "  <li><span class=\"font-medium\">Preprocessing:</span> Two tables are computed before searching to enable efficient skipping.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">The Two Rules</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">1. Bad Character Rule</h4>",
            "<div class=\"pl-4\">",
            "  <p>When a mismatch occurs at position i in the pattern:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>Look at the mismatched character c in the text</li>",
            "    <li>Find the rightmost occurrence of c in the pattern to the left of the mismatch</li>",
            "    <li>If c doesn't appear in the pattern, shift the pattern past the mismatched character</li>",
            "    <li>If c appears in the pattern, align it with the mismatched occurrence</li>",
            "  </ul>",
            "  <p class=\"italic text-sm\">This rule allows the algorithm to skip ahead when it encounters a character in the text that doesn't exist in the pattern or is far to the left in the pattern.</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">2. Good Suffix Rule</h4>",
            "<div class=\"pl-4\">",
            "  <p>When a mismatch occurs, with some suffix of the pattern already matched:</p>",
            "  <ul class=\"list-disc pl-6 mb-2\">",
            "    <li>Find the rightmost occurrence of the matched suffix elsewhere in the pattern</li>",
            "    <li>If found, shift the pattern to align with this occurrence</li>",
            "    <li>If not found, find the longest prefix of the pattern that matches a suffix of the matched portion</li>",
            "  </ul>",
            "  <p class=\"italic text-sm\">This rule helps when part of the pattern has matched successfully, allowing the algorithm to skip ahead to the next potential match based on what has already matched.</p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<p>Boyer-Moore performs best when the pattern is long and the alphabet is large. In practice, it can achieve sub-linear time by skipping portions of the text, especially when searching for long patterns.</p>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Best case:</span> O(n/m) - when each comparison causes a skip of the entire pattern length</li>",
            "  <li><span class=\"font-medium\">Average case:</span> O(n) - linear with respect to the text length</li>",
            "  <li><span class=\"font-medium\">Worst case:</span> O(n×m) - when the pattern and text consist of the same repeated character</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure BoyerMoore(text: string, pattern: string)",
            "    n := length(text)",
            "    m := length(pattern)",
            "    matches := empty array",
            "",
            "    // Preprocessing",
            "    badCharTable := computeBadCharTable(pattern)",
            "    goodSuffixTable := computeGoodSuffixTable(pattern)",
            "",
            "    // Searching phase",
            "    i := 0 // text position",
            "    while i <= n - m do",
            "        j := m - 1 // pattern position (starting from end)",
            "        // Compare pattern with text from right to left",
            "        while j >= 0 and pattern[j] = text[i + j] do",
            "            j := j - 1",
            "        end while",
            "",
            "        // If pattern fully matched",
            "        if j < 0 then",
            "            add i to matches // Pattern found at index i",
            "            i := i + goodSuffixTable[0] // Shift after a match",
            "        else",
            "            // Mismatch occurred, determine shift distance",
            "            badCharShift := j - badCharTable[text[i + j]]",
            "            if badCharShift < 1 then",
            "                badCharShift := 1",
            "            end if",
            "",
            "            goodSuffixShift := goodSuffixTable[j]",
            "            // Choose maximum of the two shifts",
            "            i := i + max(badCharShift, goodSuffixShift)",
            "        end if",
            "    end while",
            "",
            "    return matches",
            "end procedure",
            "",
            "procedure computeBadCharTable(pattern)",
            "    m := length(pattern)",
            "    table := new array initialized with -1",
            "    for j := 0 to m - 2 do",
            "        table[pattern[j]] := j",
            "    end for",
            "    return table",
            "end procedure",
            "",
            "procedure computeGoodSuffixTable(pattern)",
            "    m := length(pattern)",
            "    table := new array of size m",
            "    // First pass: case where suffix appears elsewhere in pattern",
            "    for j := 0 to m - 1 do",
            "        table[j] := m // Default shift by pattern length",
            "    end for",
            "    // Additional preprocessing for more efficient shifts",
            "    // (implementation details omitted for brevity)",
            "    return table",
            "end procedure"
          ],
          "visualizationSteps": [
            "Preprocess pattern to create bad character and good suffix tables",
            "Align pattern with text and compare characters from right to left",
            "If a mismatch occurs, use the bad character and good suffix rules to determine shift distance",
            "Choose the maximum shift distance from both rules",
            "Skip unnecessary comparisons by shifting the pattern efficiently",
            "Continue until end of text is reached or all matches are found"
          ]
        }
      ]
    },
    {
      "id": "tree",
      "name": "Tree Algorithms",
      "description": "Algorithms that operate on tree data structures such as binary trees, binary search trees, and balanced trees.",
      "algorithms": [
        {
          "id": "inorder-traversal",
          "name": "Inorder Traversal",
          "description": "Visits all nodes in a binary tree in the order: left subtree, root, right subtree. Commonly used to visit binary tree nodes in ascending order.",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(h) where h is the height of the tree",
          "howItWorks": [
            "<p>Inorder Traversal is a fundamental tree traversal algorithm that visits all nodes of a binary tree in a specific order: left subtree, root, then right subtree. For binary search trees, this traversal visits nodes in ascending order.</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Recursive Nature:</span> Naturally implemented using recursion, though iterative versions exist.</li>",
            "  <li><span class=\"font-medium\">Ordered Access:</span> Visits nodes in ascending order in a binary search tree.</li>",
            "  <li><span class=\"font-medium\">Depth-First:</span> Explores branches completely before moving to siblings.</li>",
            "  <li><span class=\"font-medium\">Stack-Based:</span> Uses system stack (recursive) or explicit stack (iterative) for tracking.</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<div class=\"pl-4\">",
            "  <ol class=\"list-decimal pl-6 mb-2\">",
            "    <li>Start at the root node</li>",
            "    <li>Recursively traverse the left subtree</li>",
            "    <li>Visit the current node (process its value)</li>",
            "    <li>Recursively traverse the right subtree</li>",
            "    <li>Base case: return when node is null</li>",
            "  </ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Example</h3>",
            "<p>Consider this binary tree:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "         4<br/>",
            "       /   \\<br/>",
            "      2     6<br/>",
            "     / \\   / \\<br/>",
            "    1   3 5   7<br/><br/>",
            "    <span class=\"font-medium\">Traversal Order:</span><br/>",
            "    1. Visit left subtree of 4 (starts with 2)<br/>",
            "    2. Visit left subtree of 2 (1)<br/>",
            "    3. Visit 2<br/>",
            "    4. Visit right subtree of 2 (3)<br/>",
            "    5. Visit 4<br/>",
            "    6. Visit left subtree of 6 (5)<br/>",
            "    7. Visit 6<br/>",
            "    8. Visit right subtree of 6 (7)<br/><br/>",
            "    <span class=\"font-medium\">Final Output:</span> [1, 2, 3, 4, 5, 6, 7]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance Analysis</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span> O(n) - must visit each node exactly once</li>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(h) where h is the tree height</li>",
            "  <li>Best case space: O(log n) for balanced trees</li>",
            "  <li>Worst case space: O(n) for skewed trees</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Applications</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Evaluating binary expression trees</li>",
            "  <li>Getting sorted order from a binary search tree</li>",
            "  <li>Parsing mathematical expressions</li>",
            "  <li>Generating postfix notation from expression trees</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Variations</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Recursive:</span> Natural implementation using system stack</li>",
            "  <li><span class=\"font-medium\">Iterative with Stack:</span> Explicit stack-based implementation</li>",
            "  <li><span class=\"font-medium\">Morris Traversal:</span> O(1) space complexity using temporary tree modifications</li>",
            "</ul>"
          ],
          "pseudocode": [
            "procedure inorderTraversal(node)",
            "    if node = null then",
            "        return",
            "    end if",
            "    inorderTraversal(node.left)",
            "    visit(node)",
            "    inorderTraversal(node.right)",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start at the root node",
            "Recursively traverse the left subtree",
            "Visit (process) the current node",
            "Recursively traverse the right subtree",
            "Continue until all nodes are visited"
          ]
        },
        {
          "id": "preorder-traversal",
          "name": "Preorder Traversal",
          "description": "A tree traversal algorithm that visits each node in a binary tree in the order: root node, left subtree, right subtree. This traversal is commonly used when you need to explore roots before leaves.",
          "category": "tree",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(h) where h is the height of the tree",
          "pseudocode": [
            "preorder(node):",
            "  if node is null, return",
            "  visit(node)",
            "  preorder(node.left)",
            "  preorder(node.right)"
          ],
          "visualizationSteps": [
            "Initialize an empty result array",
            "Start at the root node",
            "Visit the current node (add its value to the result)",
            "Recursively visit the left subtree",
            "Recursively visit the right subtree",
            "Return the result array containing the preorder traversal"
          ],
          "howItWorks": [
            "<div class='space-y-4'>",
            "<p>Preorder traversal is a systematic way to visit all nodes in a binary tree by following a <strong>root-left-right</strong> pattern. Here's how it works:</p>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li>First, visit the current node (root)</li>",
            "<li>Then, recursively traverse the left subtree</li>",
            "<li>Finally, recursively traverse the right subtree</li>",
            "</ul>",
            "<p>For example, in this tree:</p>",
            "<pre class='bg-gray-100 p-2 rounded'>    A\n   / \\\n  B   C\n / \\\n D   E</pre>",
            "<p>The preorder traversal would yield: A, B, D, E, C</p>",
            "<p>Key features:</p>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li>Always processes the root before its children</li>",
            "<li>Useful for creating a copy of a tree or prefix expression trees</li>",
            "<li>Implementation can be done recursively or iteratively using a stack</li>",
            "</ul>",
            "<p>The time complexity is O(n) as each node is visited exactly once, and the space complexity is O(h) where h is the height of the tree (due to the recursive call stack).</p>",
            "</div>"
          ]
        },
        {
          "id": "postorder-traversal",
          "name": "Postorder Traversal",
          "description": "A tree traversal algorithm that visits each node in a binary tree in the order: left subtree, right subtree, root node. This traversal is commonly used for operations that need to process children before their parents.",
          "category": "tree",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(h) where h is the height of the tree",
          "pseudocode": [
            "postorder(node):",
            "  if node is null, return",
            "  postorder(node.left)",
            "  postorder(node.right)",
            "  visit(node)"
          ],
          "visualizationSteps": [
            "Initialize an empty result array",
            "Start at the root node",
            "Recursively visit the left subtree",
            "Recursively visit the right subtree",
            "Visit the current node (add its value to the result)",
            "Return the result array containing the postorder traversal"
          ],
          "howItWorks": [
            "<div class='space-y-4'>",
            "<p>Postorder traversal is a systematic way to visit all nodes in a binary tree by following a <strong>left-right-root</strong> pattern. Here's how it works:</p>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li>First, recursively traverse the left subtree</li>",
            "<li>Then, recursively traverse the right subtree</li>",
            "<li>Finally, visit the current node (root)</li>",
            "</ul>",
            "<p>For example, in this tree:</p>",
            "<pre class='bg-gray-100 p-2 rounded'>    A\n   / \\\n  B   C\n / \\\n D   E</pre>",
            "<p>The postorder traversal would yield: D, E, B, C, A</p>",
            "<p>Key features:</p>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li>Always processes children before their parent nodes</li>",
            "<li>Extremely useful for deletion operations and mathematical expression evaluation</li>",
            "<li>Used in operations where parent nodes depend on values of their children</li>",
            "<li>The last node visited is always the root</li>",
            "</ul>",
            "<p>Applications:</p>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li>Deleting nodes and subtrees (children must be deleted before parents)</li>",
            "<li>Evaluating postfix expressions</li>",
            "<li>Finding the height of a tree</li>",
            "<li>Space-efficient tree traversal using the Morris traversal technique</li>",
            "</ul>",
            "<p>The time complexity is O(n) as each node is visited exactly once, and the space complexity is O(h) where h is the height of the tree (due to the recursive call stack).</p>",
            "</div>"
          ]
        },
        {
          "id": "level-order-traversal",
          "name": "Level Order Traversal",
          "description": "A breadth-first tree traversal algorithm that visits nodes level by level, from left to right. This traversal processes all nodes at the current depth before moving to nodes at the next depth level.",
          "category": "tree",
          "timeComplexity": {
            "best": "O(n)",
            "average": "O(n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(w) where w is the maximum width of the tree",
          "pseudocode": [
            "levelOrderTraversal(root):",
            "  if root is null, return",
            "  create an empty queue q",
            "  enqueue root to q",
            "  while q is not empty:",
            "    node = dequeue from q",
            "    visit(node)",
            "    if node.left is not null:",
            "      enqueue node.left to q",
            "    if node.right is not null:",
            "      enqueue node.right to q"
          ],
          "visualizationSteps": [
            "Initialize an empty queue and result array",
            "Enqueue the root node into the queue",
            "While the queue is not empty:",
            "  Dequeue a node and add its value to the result",
            "  Enqueue the node's left child if it exists",
            "  Enqueue the node's right child if it exists",
            "Return the result array containing the level order traversal"
          ],
          "howItWorks": [
            "<div class='space-y-4'>",
            "<p>Level Order Traversal (also known as Breadth-First Traversal) is a method of visiting all nodes in a binary tree by processing them level-by-level, starting from the root and moving downward, visiting all nodes at the current level before proceeding to the next level.</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features</h3>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li><span class=\"font-medium\">Breadth-First Approach:</span> Processes all nodes at one level before moving to the next level</li>",
            "<li><span class=\"font-medium\">Queue-Based:</span> Uses a queue data structure rather than recursion</li>",
            "<li><span class=\"font-medium\">Level-Aware:</span> Can easily be modified to track which level each node belongs to</li>",
            "<li><span class=\"font-medium\">Non-Recursive:</span> Typically implemented iteratively with a queue</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">How It Works</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Algorithm Steps</h4>",
            "<ol class='list-decimal pl-5 space-y-2'>",
            "<li>Create an empty queue and enqueue the root node</li>",
            "<li>While the queue is not empty:</li>",
            "<li class='ml-4'>Dequeue a node from the front of the queue</li>",
            "<li class='ml-4'>Visit (process) the dequeued node</li>",
            "<li class='ml-4'>Enqueue the node's left child if it exists</li>",
            "<li class='ml-4'>Enqueue the node's right child if it exists</li>",
            "</ol>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Example</h3>",
            "<p>Consider this binary tree:</p>",
            "<div class=\"pl-4 my-3\">",
            "  <p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "         4<br/>",
            "       /   \\<br/>",
            "      2     6<br/>",
            "     / \\   / \\<br/>",
            "    1   3 5   7<br/><br/>",
            "    <span class=\"font-medium\">Traversal Process:</span><br/>",
            "    1. Enqueue and visit root (4)<br/>",
            "    2. Enqueue 4's children: 2, 6<br/>",
            "    3. Dequeue and visit 2<br/>",
            "    4. Enqueue 2's children: 1, 3<br/>",
            "    5. Dequeue and visit 6<br/>",
            "    6. Enqueue 6's children: 5, 7<br/>",
            "    7. Dequeue and visit 1, 3, 5, 7 in sequence<br/><br/>",
            "    <span class=\"font-medium\">Final Output:</span> [4, 2, 6, 1, 3, 5, 7]",
            "  </p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance Analysis</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Time Complexity:</span> O(n) - each node is visited exactly once</li>",
            "  <li><span class=\"font-medium\">Space Complexity:</span> O(w) where w is the maximum width of the tree</li>",
            "  <li>Best case space: O(1) for a degenerate tree (like a linked list)</li>",
            "  <li>Worst case space: O(n/2) ≈ O(n) for a complete binary tree where the last level has approximately n/2 nodes</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Applications</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Level-by-level processing of tree nodes</li>",
            "  <li>Finding the minimum depth of a binary tree</li>",
            "  <li>Printing level order traversal of a tree</li>",
            "  <li>Connecting nodes at the same level in a binary tree</li>",
            "  <li>Zigzag or spiral tree traversal (with simple modifications)</li>",
            "  <li>Level averaging in a binary tree</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Advantages</h3>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Easy to implement level-aware operations</li>",
            "  <li>Natural fit for problems requiring level-by-level processing</li>",
            "  <li>Can be used to find the shortest path in unweighted graphs</li>",
            "  <li>Enables early termination for problems like finding the closest node</li>",
            "</ul>"
          ]
        },
        {
          "id": "binary-search-tree",
          "name": "Binary Search Tree Operations",
          "description": "A Binary Search Tree (BST) is a binary tree data structure that maintains the BST property: for each node, all elements in the left subtree are less than the node's key, and all elements in the right subtree are greater. This algorithm visualizes the fundamental BST operations: search, insert, and delete.",
          "category": "tree",
          "timeComplexity": {
            "best": "O(log n)",
            "average": "O(log n)",
            "worst": "O(n)"
          },
          "spaceComplexity": "O(h) where h is the height of the tree",
          "pseudocode": [
            "// SEARCH OPERATION",
            "function search(root, key):",
            "  if root is null or root.key equals key:",
            "    return root",
            "    ",
            "  if key < root.key:",
            "    return search(root.left, key)",
            "  else:",
            "    return search(root.right, key)",
            "",
            "// INSERT OPERATION",
            "function insert(root, key):",
            "  if root is null:",
            "    return new Node(key)",
            "",
            "  if key < root.key:",
            "    root.left = insert(root.left, key)",
            "  else if key > root.key:",
            "    root.right = insert(root.right, key)",
            "",
            "  return root",
            "",
            "// DELETE OPERATION",
            "function delete(root, key):",
            "  if root is null:",
            "    return root",
            "",
            "  if key < root.key:",
            "    root.left = delete(root.left, key)",
            "  else if key > root.key:",
            "    root.right = delete(root.right, key)",
            "  else:",
            "    // Node with one or no child",
            "    if root.left is null:",
            "      return root.right",
            "    else if root.right is null:",
            "      return root.left",
            "",
            "    // Node with two children",
            "    root.key = minValue(root.right)  // Find inorder successor",
            "    root.right = delete(root.right, root.key)",
            "",
            "  return root",
            "",
            "function minValue(node):",
            "  current = node",
            "  while current.left is not null:",
            "    current = current.left",
            "  return current.key"
          ],
          "visualizationSteps": [
            "For Search: Start at the root and compare the target value with the current node",
            "If the value matches, the search is successful",
            "If the value is less than the current node, search in the left subtree",
            "If the value is greater than the current node, search in the right subtree",
            "Continue until the value is found or a leaf is reached",
            "",
            "For Insert: Follow the search path for the value",
            "When a null pointer (empty spot) is reached, create a new node and attach it at that position",
            "",
            "For Delete: Find the node to be deleted",
            "If the node has no children, simply remove it",
            "If the node has one child, replace the node with its child",
            "If the node has two children, find the inorder successor (smallest node in right subtree), replace the node's value with it, and delete the successor"
          ],
          "howItWorks": [
            "<div class='space-y-4'>",
            "<p>A Binary Search Tree (BST) is a special type of binary tree that satisfies the BST property: for any node, all elements in the left subtree are less than the node's value, and all elements in the right subtree are greater than the node's value.</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features of Binary Search Trees</h3>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li><span class=\"font-medium\">Ordered Structure:</span> Elements are stored in a way that enables efficient search, insert, and delete operations</li>",
            "<li><span class=\"font-medium\">Binary Property:</span> Each node has at most two children (left and right)</li>",
            "<li><span class=\"font-medium\">BST Property:</span> For every node, all elements in its left subtree are less than the node, and all elements in its right subtree are greater</li>",
            "<li><span class=\"font-medium\">Duplicates:</span> Usually not allowed, although variations can handle them by either storing a count or placing them in a specific subtree</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Basic Operations</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">1. Search</h4>",
            "<div class=\"pl-4\">",
            "<p>Searching in a BST involves traversing the tree to find a specific value:</p>",
            "<ol class='list-decimal pl-5 space-y-2'>",
            "<li>Start at the root node</li>",
            "<li>If the current node contains the target value, the search is successful</li>",
            "<li>If the target value is less than the current node's value, recursively search in the left subtree</li>",
            "<li>If the target value is greater than the current node's value, recursively search in the right subtree</li>",
            "<li>If we reach a null pointer (empty subtree), the value is not in the tree</li>",
            "</ol>",
            "<p class=\"mt-2\"><span class=\"font-medium\">Time Complexity:</span> O(log n) for balanced trees, O(n) for skewed trees (worst case)</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">2. Insert</h4>",
            "<div class=\"pl-4\">",
            "<p>Insertion adds a new value to the BST while maintaining the BST property:</p>",
            "<ol class='list-decimal pl-5 space-y-2'>",
            "<li>Start by searching for the value in the tree (following the search algorithm)</li>",
            "<li>When we reach a null pointer, insert the new node at that position</li>",
            "<li>If the value is less than the parent node, attach as left child</li>",
            "<li>If the value is greater than the parent node, attach as right child</li>",
            "</ol>",
            "<p class=\"mt-2\"><span class=\"font-medium\">Time Complexity:</span> O(log n) for balanced trees, O(n) for skewed trees (worst case)</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">3. Delete</h4>",
            "<div class=\"pl-4\">",
            "<p>Deletion is the most complex operation and has three cases:</p>",
            "<ol class='list-decimal pl-5 space-y-2'>",
            "<li><strong>Case 1: Node has no children (leaf node)</strong>",
            "<ul class='list-disc pl-5 mt-1 mb-2'>",
            "<li>Simply remove the node by setting its parent's reference to null</li>",
            "</ul>",
            "</li>",
            "<li><strong>Case 2: Node has one child</strong>",
            "<ul class='list-disc pl-5 mt-1 mb-2'>",
            "<li>Replace the node with its child by updating the parent's reference</li>",
            "</ul>",
            "</li>",
            "<li><strong>Case 3: Node has two children</strong>",
            "<ul class='list-disc pl-5 mt-1 mb-2'>",
            "<li>Find the inorder successor (smallest node in the right subtree) or inorder predecessor (largest node in the left subtree)</li>",
            "<li>Replace the node's value with the successor's/predecessor's value</li>",
            "<li>Delete the successor/predecessor node (which will have at most one child)</li>",
            "</ul>",
            "</li>",
            "</ol>",
            "<p class=\"mt-2\"><span class=\"font-medium\">Time Complexity:</span> O(log n) for balanced trees, O(n) for skewed trees (worst case)</p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visual Example</h3>",
            "<div class=\"pl-4 my-3\">",
            "<p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "         50<br/>",
            "       /   \\<br/>",
            "      30     70<br/>",
            "     / \\   / \\<br/>",
            "    20  40 60  80<br/>",
            "</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Search Example</h4>",
            "<div class=\"pl-4\">",
            "<p>To search for value 40 in the BST above:</p>",
            "<ol class='list-decimal pl-5 space-y-1 text-sm'>",
            "<li>Start at root (50)</li>",
            "<li>40 < 50, so go to left subtree</li>",
            "<li>At node 30: 40 > 30, so go to right subtree</li>",
            "<li>At node 40: Match found! Search successful</li>",
            "</ol>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Insert Example</h4>",
            "<div class=\"pl-4\">",
            "<p>To insert value 55 in the BST above:</p>",
            "<ol class='list-decimal pl-5 space-y-1 text-sm'>",
            "<li>Start at root (50)</li>",
            "<li>55 > 50, so go to right subtree</li>",
            "<li>At node 70: 55 < 70, so go to left subtree</li>",
            "<li>At node 60: 55 < 60, so go to left subtree</li>",
            "<li>Left child of 60 is null, so insert 55 as left child of 60</li>",
            "</ol>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Delete Example</h4>",
            "<div class=\"pl-4\">",
            "<p>To delete value 30 from the BST above:</p>",
            "<ol class='list-decimal pl-5 space-y-1 text-sm'>",
            "<li>Start at root (50)</li>",
            "<li>30 < 50, so go to left subtree</li>",
            "<li>Found node 30 to delete</li>",
            "<li>Node 30 has two children (20 and 40)</li>",
            "<li>Find the inorder successor (smallest in right subtree), which is 40</li>",
            "<li>Replace 30's value with 40</li>",
            "<li>Delete the original node containing 40 (which has no children)</li>",
            "</ol>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance and Applications</h3>",
            "<h4 class=\"text-lg font-medium mt-3 mb-1 text-gray-800\">Time Complexity</h4>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li><span class=\"font-medium\">Search:</span> O(log n) average, O(n) worst case</li>",
            "  <li><span class=\"font-medium\">Insert:</span> O(log n) average, O(n) worst case</li>",
            "  <li><span class=\"font-medium\">Delete:</span> O(log n) average, O(n) worst case</li>",
            "</ul>",
            "<p>Note: The worst-case O(n) occurs in skewed trees, where the tree resembles a linked list.</p>",
            "<h4 class=\"text-lg font-medium mt-3 mb-1 text-gray-800\">Applications</h4>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Implementations of other data structures like sets, maps, and priority queues</li>",
            "  <li>Database indexing</li>",
            "  <li>Syntax trees in compilers</li>",
            "  <li>Searching and sorting applications</li>",
            "</ul>",
            "<h4 class=\"text-lg font-medium mt-3 mb-1 text-gray-800\">Advantages</h4>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Efficient search, insert, and delete operations when balanced</li>",
            "  <li>Maintains data in a sorted order, enabling in-order traversal to obtain sorted data</li>",
            "  <li>Flexible dynamic data structure (can grow or shrink during execution)</li>",
            "</ul>",
            "<h4 class=\"text-lg font-medium mt-3 mb-1 text-gray-800\">Limitations</h4>",
            "<ul class=\"list-disc pl-6 mb-4\">",
            "  <li>Performance degrades to O(n) in worst case (skewed trees)</li>",
            "  <li>No constant-time operations (unlike arrays or hash tables)</li>",
            "  <li>Requires additional mechanisms (like self-balancing) to maintain O(log n) complexity</li>",
            "</ul>",
            "<p>Various self-balancing BST variations exist to address the skewness problem, including AVL trees, Red-Black trees, Splay trees, and B-trees.</p>",
            "</div>"
          ]
        },
        {
          "id": "avl-tree",
          "name": "AVL Tree Operations",
          "description": "AVL tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot exceed one for all nodes. This algorithm visualizes the operations on an AVL tree including insertion, deletion, and the resulting rotations to maintain balance.",
          "category": "tree",
          "timeComplexity": {
            "best": "O(log n)",
            "average": "O(log n)",
            "worst": "O(log n)"
          },
          "spaceComplexity": "O(log n)",
          "pseudocode": [
            "// NODE STRUCTURE",
            "class Node:",
            "  value: integer",
            "  left: Node (or null)",
            "  right: Node (or null)",
            "  height: integer",
            "",
            "// GET HEIGHT",
            "function getHeight(node):",
            "  if node is null:",
            "    return 0",
            "  return node.height",
            "",
            "// GET BALANCE FACTOR",
            "function getBalanceFactor(node):",
            "  if node is null:",
            "    return 0",
            "  return getHeight(node.left) - getHeight(node.right)",
            "",
            "// RIGHT ROTATION",
            "function rightRotate(y):",
            "  x = y.left",
            "  T2 = x.right",
            "",
            "  // Perform rotation",
            "  x.right = y",
            "  y.left = T2",
            "",
            "  // Update heights",
            "  y.height = max(getHeight(y.left), getHeight(y.right)) + 1",
            "  x.height = max(getHeight(x.left), getHeight(x.right)) + 1",
            "",
            "  return x  // New root",
            "",
            "// LEFT ROTATION",
            "function leftRotate(x):",
            "  y = x.right",
            "  T2 = y.left",
            "",
            "  // Perform rotation",
            "  y.left = x",
            "  x.right = T2",
            "",
            "  // Update heights",
            "  x.height = max(getHeight(x.left), getHeight(x.right)) + 1",
            "  y.height = max(getHeight(y.left), getHeight(y.right)) + 1",
            "",
            "  return y  // New root",
            "",
            "// INSERT NODE",
            "function insert(root, key):",
            "  // Standard BST insert",
            "  if root is null:",
            "    return new Node(key, height=1)",
            "    ",
            "  if key < root.value:",
            "    root.left = insert(root.left, key)",
            "  else if key > root.value:",
            "    root.right = insert(root.right, key)",
            "  else:",
            "    return root  // Duplicate keys not allowed",
            "",
            "  // Update height of current node",
            "  root.height = max(getHeight(root.left), getHeight(root.right)) + 1",
            "",
            "  // Get balance factor to check if node became unbalanced",
            "  balance = getBalanceFactor(root)",
            "",
            "  // Left Heavy",
            "  if balance > 1:",
            "    // Left-Left Case",
            "    if key < root.left.value:",
            "      return rightRotate(root)",
            "    // Left-Right Case",
            "    else:",
            "      root.left = leftRotate(root.left)",
            "      return rightRotate(root)",
            "",
            "  // Right Heavy",
            "  if balance < -1:",
            "    // Right-Right Case",
            "    if key > root.right.value:",
            "      return leftRotate(root)",
            "    // Right-Left Case",
            "    else:",
            "      root.right = rightRotate(root.right)",
            "      return leftRotate(root)",
            "",
            "  return root"
          ],
          "visualizationSteps": [
            "Start with an AVL tree (a balanced binary search tree)",
            "For Insert: Follow BST insertion rules to add the new node",
            "Update the height of each node in the path from the inserted node to the root",
            "Check the balance factor at each node in this path",
            "If a node becomes unbalanced (balance factor > 1 or < -1), perform appropriate rotations",
            "Left-Left Case: Perform a right rotation",
            "Left-Right Case: Perform a left rotation on the left child, then a right rotation",
            "Right-Right Case: Perform a left rotation",
            "Right-Left Case: Perform a right rotation on the right child, then a left rotation",
            "The tree is now balanced with all operations maintaining O(log n) complexity"
          ],
          "howItWorks": [
            "<div class='space-y-4'>",
            "<p>An AVL tree is a self-balancing binary search tree where the difference between heights of left and right subtrees cannot be more than one for all nodes. This balancing ensures operations maintain O(log n) time complexity even in worst cases.</p>",
            "<h3 class=\"text-xl font-semibold mt-4 mb-2 text-gray-800\">Key Features of AVL Trees</h3>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li><span class=\"font-medium\">Self-Balancing:</span> Automatically rebalances after insertions and deletions</li>",
            "<li><span class=\"font-medium\">Height Balance Property:</span> For any node, the heights of its left and right subtrees differ by at most 1</li>",
            "<li><span class=\"font-medium\">BST Property:</span> Maintains binary search tree property (left subtree values < node value < right subtree values)</li>",
            "<li><span class=\"font-medium\">Guaranteed Performance:</span> Operations are O(log n) in worst case, unlike regular BSTs</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Core Concepts</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">1. Balance Factor</h4>",
            "<div class=\"pl-4\">",
            "<p>The balance factor of a node is the height of its left subtree minus the height of its right subtree:</p>",
            "<ul class='list-disc pl-5 mt-2'>",
            "<li>Balance Factor = Height(Left Subtree) - Height(Right Subtree)</li>",
            "<li>A node is balanced if its balance factor is -1, 0, or 1</li>",
            "<li>If balance factor is > 1, the node is left-heavy</li>",
            "<li>If balance factor is < -1, the node is right-heavy</li>",
            "</ul>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">2. Rotations</h4>",
            "<div class=\"pl-4\">",
            "<p>When a node becomes unbalanced, one of four rotation operations is performed to restore balance:</p>",
            "<ol class='list-decimal pl-5 space-y-2'>",
            "<li><strong>Left Rotation:</strong> Used when a node is right-heavy and its right child is balanced or right-heavy</li>",
            "<li><strong>Right Rotation:</strong> Used when a node is left-heavy and its left child is balanced or left-heavy</li>",
            "<li><strong>Left-Right Rotation:</strong> Used when a node is left-heavy but its left child is right-heavy</li>",
            "<li><strong>Right-Left Rotation:</strong> Used when a node is right-heavy but its right child is left-heavy</li>",
            "</ol>",
            "<p class=\"mt-2\">These rotations reorganize the tree structure while preserving the BST property.</p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Operations</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">1. Insert</h4>",
            "<div class=\"pl-4\">",
            "<ol class='list-decimal pl-5 space-y-2'>",
            "<li>Perform standard BST insertion</li>",
            "<li>Update height of each ancestor node</li>",
            "<li>Check balance factor of each ancestor node</li>",
            "<li>If any node becomes unbalanced, perform the appropriate rotation:</li>",
            "</ol>",
            "<div class=\"pl-5 my-3\">",
            "<p class=\"font-medium\">Four cases for rotations:</p>",
            "<ul class='list-disc pl-5 mt-1'>",
            "<li><strong>Left-Left Case:</strong> Node is left-heavy and the new node was inserted in the left subtree of the left child</li>",
            "<li><strong>Left-Right Case:</strong> Node is left-heavy and the new node was inserted in the right subtree of the left child</li>",
            "<li><strong>Right-Right Case:</strong> Node is right-heavy and the new node was inserted in the right subtree of the right child</li>",
            "<li><strong>Right-Left Case:</strong> Node is right-heavy and the new node was inserted in the left subtree of the right child</li>",
            "</ul>",
            "</div>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Visualizing Rotations</h3>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Right Rotation Example</h4>",
            "<div class=\"pl-4 my-3\">",
            "<p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "    y                x<br/>",
            "   / \\              / \\<br/>",
            "  x   T3   -->     T1  y<br/>",
            " / \\                  / \\<br/>",
            "T1  T2               T2  T3<br/>",
            "</p>",
            "</div>",
            "<h4 class=\"text-lg font-medium mt-4 mb-1 text-gray-800\">Left Rotation Example</h4>",
            "<div class=\"pl-4 my-3\">",
            "<p class=\"font-mono text-sm bg-gray-50 p-2 rounded\">",
            "  x                 y<br/>",
            " / \\               / \\<br/>",
            "T1  y     -->     x   T3<br/>",
            "   / \\           / \\<br/>",
            "  T2  T3        T1  T2<br/>",
            "</p>",
            "</div>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Performance</h3>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li><span class=\"font-medium\">Time Complexity:</span></li>",
            "<ul class='list-disc pl-5 mt-1 mb-2'>",
            "<li>Search: O(log n)</li>",
            "<li>Insert: O(log n)</li>",
            "<li>Delete: O(log n)</li>",
            "</ul>",
            "<li><span class=\"font-medium\">Space Complexity:</span> O(log n) - for recursion stack</li>",
            "</ul>",
            "<h3 class=\"text-xl font-semibold mt-5 mb-2 text-gray-800\">Applications</h3>",
            "<ul class='list-disc pl-5 space-y-2'>",
            "<li>Database indexing</li>",
            "<li>Priority queues</li>",
            "<li>Statistical data structures</li>",
            "<li>Any application requiring balanced search trees with guaranteed performance</li>",
            "</ul>",
            "</div>"
          ]
        }
      ]
    },
    {
      "id": "greedy",
      "name": "Greedy Algorithms",
      "description": "Algorithms that make locally optimal choices at each stage with the hope of finding a global optimum.",
      "algorithms": [
        {
          "id": "huffman-coding",
          "name": "Huffman Coding",
          "description": "A lossless data compression algorithm that uses variable-length codes to represent characters, with shorter codes for more frequent characters.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n log n)",
            "worst": "O(n log n)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure HuffmanCoding(C: array of characters, F: array of frequencies):",
            "    n := length(C)",
            "    // Create a priority queue of nodes, initially containing leaf nodes for all characters",
            "    Q := new PriorityQueue()",
            "    for i := 1 to n do",
            "        node := new Node(C[i], F[i], null, null)",
            "        Q.enqueue(node)",
            "    end for",
            "",
            "    // Build the Huffman tree",
            "    for i := 1 to n-1 do",
            "        // Extract two nodes with lowest frequencies",
            "        left := Q.dequeue()",
            "        right := Q.dequeue()",
            "        // Create a new internal node with these two as children",
            "        newFreq := left.freq + right.freq",
            "        newNode := new Node(null, newFreq, left, right)",
            "        // Add the new node back to the queue",
            "        Q.enqueue(newNode)",
            "    end for",
            "",
            "    // The last remaining node is the root of the Huffman tree",
            "    root := Q.dequeue()",
            "",
            "    // Assign codes by traversing the tree",
            "    codes := new Map()",
            "    assignCodes(root, \"\", codes)",
            "    return codes",
            "end procedure",
            "",
            "procedure assignCodes(node, code, codes):",
            "    if node is a leaf node then",
            "        codes[node.char] := code",
            "        return",
            "    end if",
            "    // Recursive calls for left and right children",
            "    assignCodes(node.left, code + \"0\", codes)",
            "    assignCodes(node.right, code + \"1\", codes)",
            "end procedure"
          ],
          "visualizationSteps": [
            "Create leaf nodes for each character with its frequency",
            "Build a priority queue with all leaf nodes",
            "Extract two nodes with lowest frequencies",
            "Create a new internal node as their parent with frequency = sum of children",
            "Add the new node back to the queue",
            "Repeat until only one node remains (the root)",
            "Assign 0 to edges going to left children and 1 to right",
            "Read the codes by following paths from root to leaves"
          ]
        },
        {
          "id": "job-sequencing",
          "name": "Job Sequencing",
          "description": "Schedules jobs to maximize profit, where each job has a deadline and profit.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n²)",
            "worst": "O(n²)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure JobSequencing(jobs: array of (id, deadline, profit)):",
            "    // Sort jobs by decreasing profit",
            "    sort jobs in decreasing order of profit",
            "    ",
            "    n := number of jobs",
            "    maxDeadline := maximum deadline among all jobs",
            "    ",
            "    // Initialize result array and slot array",
            "    result := array of size maxDeadline initialized to -1",
            "    slot := array of size maxDeadline initialized to false",
            "    ",
            "    // Iterate through all jobs",
            "    for i := 1 to n do",
            "        // Find a free slot for this job",
            "        for j := min(maxDeadline, jobs[i].deadline) down to 1 do",
            "            if slot[j] = false then",
            "                result[j] := i",
            "                slot[j] := true",
            "                break",
            "            end if",
            "        end for",
            "    end for",
            "    ",
            "    return result",
            "end procedure"
          ],
          "visualizationSteps": [
            "Sort all jobs in decreasing order of profit",
            "Initialize a result sequence and time slots",
            "For each job, find the latest free time slot before its deadline",
            "If a free slot is found, schedule the job in that slot",
            "If no slot is available, skip the job",
            "Continue until all jobs are processed",
            "Return the sequence of jobs that maximizes profit"
          ]
        },
        {
          "id": "fractional-knapsack",
          "name": "Fractional Knapsack",
          "description": "Maximizes value by taking fractions of items with weight constraints, unlike the 0/1 knapsack where items cannot be broken.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n log n)",
            "worst": "O(n log n)"
          },
          "spaceComplexity": "O(1)",
          "pseudocode": [
            "procedure FractionalKnapsack(W: weight capacity, items: array of (value, weight)):",
            "    // Calculate value-to-weight ratio for each item",
            "    for i := 1 to n do",
            "        items[i].ratio := items[i].value / items[i].weight",
            "    end for",
            "    ",
            "    // Sort items by value-to-weight ratio in non-increasing order",
            "    sort items by ratio in non-increasing order",
            "    ",
            "    // Initialize variables",
            "    totalValue := 0",
            "    currentWeight := 0",
            "    ",
            "    // Process items in sorted order",
            "    for i := 1 to n do",
            "        if currentWeight + items[i].weight <= W then",
            "            // Take the whole item",
            "            currentWeight := currentWeight + items[i].weight",
            "            totalValue := totalValue + items[i].value",
            "        else",
            "            // Take a fraction of the item",
            "            remainingWeight := W - currentWeight",
            "            totalValue := totalValue + items[i].value * (remainingWeight / items[i].weight)",
            "            break",
            "        end if",
            "    end for",
            "    ",
            "    return totalValue",
            "end procedure"
          ],
          "visualizationSteps": [
            "Calculate value-to-weight ratio for each item",
            "Sort items by value-to-weight ratio in decreasing order",
            "Initialize total value and current weight to 0",
            "Process items in order, taking as much as possible",
            "If an item fits completely, take all of it",
            "If it doesn't fit, take a fraction that fits",
            "Stop when knapsack is full or all items are processed",
            "Return the maximum value obtainable"
          ]
        },
        {
          "id": "activity-selection",
          "name": "Activity Selection",
          "description": "Selects the maximum number of non-overlapping activities that can be performed by a single person, given the start and finish times of each activity.",
          "timeComplexity": {
            "best": "O(n log n)",
            "average": "O(n log n)",
            "worst": "O(n log n)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure ActivitySelection(activities: array of (start, finish)):",
            "    // Sort activities by finish time",
            "    sort activities by finish time in non-decreasing order",
            "    ",
            "    n := number of activities",
            "    selected := [1]  // First activity is always selected",
            "    lastSelected := 1",
            "    ",
            "    // Consider rest of the activities",
            "    for i := 2 to n do",
            "        // If this activity starts after the finish time of last selected",
            "        if activities[i].start >= activities[lastSelected].finish then",
            "            add i to selected",
            "            lastSelected := i",
            "        end if",
            "    end for",
            "    ",
            "    return selected",
            "end procedure"
          ],
          "visualizationSteps": [
            "Sort activities by finish time",
            "Select the first activity (earliest finish time)",
            "For each subsequent activity, check if it starts after the finish time of the last selected activity",
            "If it doesn't overlap, select it and update the last selected activity",
            "If it overlaps, skip it",
            "Continue until all activities are processed",
            "Return the maximum set of non-overlapping activities"
          ]
        },
        {
            "id": "kruskals-2",
            "name": "Kruskal's Algorithm",
            "description": "Finds a minimum spanning tree for a connected weighted graph by adding edges in order of increasing weight without creating cycles.",
            "timeComplexity": {
              "best": "O(E log E)",
              "average": "O(E log E)",
              "worst": "O(E log E)"
            },
            "spaceComplexity": "O(V + E)",
            "pseudocode": [
              "procedure Kruskal(G: graph)",
              "    A := ∅ // A will contain the edges of the MST",
              "    for each vertex v in G do",
              "        Make-Set(v) // Create a set for each vertex",
              "    end for",
              "    sort edges of G by weight in non-decreasing order",
              "    for each edge (u, v) in G, in non-decreasing order of weight do",
              "        if Find-Set(u) ≠ Find-Set(v) then",
              "            A := A ∪ {(u, v)}",
              "            Union(u, v)",
              "        end if",
              "    end for",
              "    return A",
              "end procedure"
            ],
            "visualizationSteps": [
              "Create a set for each vertex in the graph",
              "Sort all edges in non-decreasing order of their weight",
              "Consider edges in sorted order",
              "Add an edge if it doesn't create a cycle in the current MST",
              "Continue until V-1 edges are added, forming a complete MST",
              "Use Union-Find data structure to efficiently detect cycles"
            ]
        },
        {
        "id": "prims-2",
        "name": "Prim's Algorithm",
        "description": "A greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. This means it finds a subset of the edges that forms a tree that includes every vertex, where the total weight of all the edges in the tree is minimized.",
        "timeComplexity": {
            "best": "O(E log V)",
            "average": "O(E log V)",
            "worst": "O(E log V)"
        },
        "spaceComplexity": "O(V + E)",
        "pseudocode": [
            "function Prim(Graph, start):",
            "    Create a MinPriorityQueue pq",
            "    For each vertex v in Graph:",
            "        distance[v] = INFINITY",
            "        inMST[v] = false",
            "    distance[start] = 0",
            "    pq.add((0, start))",
            "    While pq is not empty:",
            "        u = pq.extractMin()",
            "        inMST[u] = true",
            "        For each neighbor v of u:",
            "            weight = edge_weight(u, v)",
            "            If inMST[v] is false AND weight < distance[v]:",
            "                distance[v] = weight",
            "                parent[v] = u",
            "                pq.add((distance[v], v))",
            "    Return MST using parent array"
        ],
        "visualizationSteps": [
            "Initialize a priority queue PQ to keep track of vertices and their minimum edge weights.",
            "Add the starting vertex to the MST and update the key values of adjacent vertices.",
            "Extract the vertex with the minimum key from PQ that is not yet in the MST.",
            "Add the extracted vertex to the MST.",
            "Update the key values of adjacent vertices if a cheaper connection is found.",
            "Repeat steps 3-5 until all vertices are included in the MST.",
            "The resulting tree is the Minimum Spanning Tree."
        ]
        },
        {
            "id": "dijkstra-2",
            "name": "Dijkstra's Algorithm",
            "description": "Finds the shortest paths from a source vertex to all other vertices in a weighted graph.",
            "timeComplexity": {
              "best": "O((V + E) log V)",
              "average": "O((V + E) log V)",
              "worst": "O((V + E) log V)"
            },
            "spaceComplexity": "O(V)",
            "pseudocode": [
              "procedure Dijkstra(G: graph, start: vertex)",
              "    for each vertex v in G do",
              "        distance[v] := infinity",
              "        previous[v] := undefined",
              "        visited[v] := false",
              "    end for",
              "    distance[start] := 0",
              "    Q := set of all vertices in G",
              "    while Q is not empty do",
              "        u := vertex in Q with minimum distance[u]",
              "        if distance[u] = infinity then",
              "            break",
              "        end if",
              "        remove u from Q",
              "        visited[u] := true",
              "        for each neighbor v of u do",
              "            if not visited[v] then",
              "                alt := distance[u] + length(u, v)",
              "                if alt < distance[v] then",
              "                    distance[v] := alt",
              "                    previous[v] := u",
              "                end if",
              "            end if",
              "        end for",
              "    end while",
              "    return distance[], previous[]",
              "end procedure"
            ],
            "visualizationSteps": [
              "Set distance of start vertex to 0, all others to infinity",
              "Select unvisited vertex with minimum distance",
              "Mark selected vertex as visited",
              "Update distances to all unvisited neighbors",
              "Repeat until all vertices are visited or remaining vertices are unreachable"
            ]
          }
      ]
    },
    {
      "id": "backtracking",
      "name": "Backtracking Algorithms",
      "description": "Algorithms that solve problems by trying different possibilities and undoing choices that don't lead to a solution.",
      "algorithms": [
        {
          "id": "n-queens",
          "name": "N-Queens Problem",
          "description": "Place N queens on an N×N chessboard so that no two queens threaten each other. Queens can attack horizontally, vertically, and diagonally.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(n!)",
            "worst": "O(n!)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure solveNQueens(board: n×n board, col: current column)",
            "    if col ≥ n then",
            "        return true // All queens are placed successfully",
            "    end if",
            "",
            "    for row := 0 to n-1 do",
            "        if isSafe(board, row, col) then",
            "            board[row][col] := 1 // Place queen",
            "            if solveNQueens(board, col + 1) then",
            "                return true",
            "            end if",
            "            board[row][col] := 0 // Backtrack",
            "        end if",
            "    end for",
            "    return false",
            "end procedure",
            "",
            "procedure isSafe(board: n×n board, row, col: positions)",
            "    // Check row on left side",
            "    for j := 0 to col-1 do",
            "        if board[row][j] = 1 then",
            "            return false",
            "        end if",
            "    end for",
            "",
            "    // Check upper diagonal",
            "    for i := row, j := col; i ≥ 0 and j ≥ 0; i--, j-- do",
            "        if board[i][j] = 1 then",
            "            return false",
            "        end if",
            "    end for",
            "",
            "    // Check lower diagonal",
            "    for i := row, j := col; i < n and j ≥ 0; i++, j-- do",
            "        if board[i][j] = 1 then",
            "            return false",
            "        end if",
            "    end for",
            "",
            "    return true",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start with an empty N×N board",
            "Try placing a queen in the first available position in current column",
            "Check if the position is safe (no queen can attack this position)",
            "If safe, place the queen and move to next column",
            "If no safe position in current column, backtrack to previous column",
            "Continue until all queens are placed or all possibilities exhausted"
          ]
        },
        {
          "id": "rat-in-maze",
          "name": "Rat in a Maze",
          "description": "Finds a path from source to destination in a maze, where the rat can only move in two directions: forward and down.",
          "timeComplexity": {
            "best": "O(2^(n²))",
            "average": "O(2^(n²))",
            "worst": "O(2^(n²))"
          },
          "spaceComplexity": "O(n²)",
          "pseudocode": [
            "procedure solveRatInMaze(maze, n)",
            "    // Initialize solution matrix",
            "    solution[n][n] := matrix with all 0s",
            "    ",
            "    if solveMazeUtil(maze, 0, 0, solution, n) then",
            "        return solution",
            "    else",
            "        return \"No solution exists\"",
            "end procedure",
            "",
            "procedure solveMazeUtil(maze, x, y, solution, n)",
            "    // Base case: if destination is reached",
            "    if x = n-1 and y = n-1 then",
            "        solution[x][y] := 1",
            "        return true",
            "    end if",
            "    ",
            "    // Check if current cell is valid",
            "    if isSafe(maze, x, y, n) then",
            "        // Mark current cell as part of solution path",
            "        solution[x][y] := 1",
            "        ",
            "        // Move forward in x direction",
            "        if solveMazeUtil(maze, x+1, y, solution, n) then",
            "            return true",
            "        end if",
            "        ",
            "        // Move down in y direction",
            "        if solveMazeUtil(maze, x, y+1, solution, n) then",
            "            return true",
            "        end if",
            "        ",
            "        // Backtrack: unmark current cell if no solution possible",
            "        solution[x][y] := 0",
            "        return false",
            "    end if",
            "    ",
            "    return false",
            "end procedure",
            "",
            "procedure isSafe(maze, x, y, n)",
            "    // Check if x, y is valid and cell is not blocked",
            "    return (x >= 0 and x < n and y >= 0 and y < n and maze[x][y] = 1)",
            "end procedure"
          ],
          "visualizationSteps": [
            "Initialize maze and solution matrix",
            "Start from source (0,0)",
            "Explore paths recursively (move right and down)",
            "Mark cells as visited when exploring",
            "Backtrack when hitting a dead end",
            "Continue until destination is reached or all paths are explored"
          ]
        },
        {
          "id": "hamiltonian-cycle",
          "name": "Hamiltonian Cycle",
          "description": "Finds a cycle that visits each vertex exactly once in a graph.",
          "timeComplexity": {
            "best": "O(1)",
            "average": "O(n!)",
            "worst": "O(n!)"
          },
          "spaceComplexity": "O(n)",
          "pseudocode": [
            "procedure hamiltonianCycle(graph)",
            "    // Initialize path array",
            "    path[V] := array of size V with all values as -1",
            "    path[0] := 0  // Start from vertex 0",
            "",
            "    if solveHamiltonianCycle(graph, path, 1) then",
            "        return path",
            "    else",
            "        return \"No solution exists\"",
            "end procedure",
            "",
            "procedure solveHamiltonianCycle(graph, path, pos)",
            "    // Base case: if all vertices are included",
            "    if pos = V then",
            "        // Check if there is an edge from last vertex to first vertex",
            "        if graph[path[pos-1]][path[0]] = 1 then",
            "            return true",
            "        else",
            "            return false",
            "        end if",
            "    end if",
            "",
            "    // Try different vertices as next candidate",
            "    for v := 1 to V-1 do",
            "        if isSafe(v, graph, path, pos) then",
            "            path[pos] := v",
            "",
            "            if solveHamiltonianCycle(graph, path, pos+1) then",
            "                return true",
            "            end if",
            "",
            "            // Remove vertex if it doesn't lead to a solution",
            "            path[pos] := -1",
            "        end if",
            "    end for",
            "",
            "    return false",
            "end procedure",
            "",
            "procedure isSafe(v, graph, path, pos)",
            "    // Check if vertex v can be added at index pos",
            "    ",
            "    // Check if vertex is adjacent to previous vertex",
            "    if graph[path[pos-1]][v] = 0 then",
            "        return false",
            "    end if",
            "",
            "    // Check if vertex is already included in path",
            "    for i := 0 to pos-1 do",
            "        if path[i] = v then",
            "            return false",
            "        end if",
            "    end for",
            "",
            "    return true",
            "end procedure"
          ],
          "visualizationSteps": [
            "Start with vertex 0 as the first vertex in the path",
            "Try adding each unvisited vertex that is adjacent to the last vertex",
            "Check if adding a vertex creates a valid partial path",
            "If valid, recursively try to complete the cycle",
            "If no solution found, backtrack by removing the last added vertex",
            "Continue until a Hamiltonian cycle is found or all possibilities are exhausted"
          ]
        }
      ]
    }
  ]
} 